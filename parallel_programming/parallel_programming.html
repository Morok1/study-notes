<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Конспект по ПП/Распределенные системы от Елизарова (3 курс)</title>
<!-- 2016-06-21 Tue 10:41 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Конспект по ПП/Распределенные системы от Елизарова (3 курс)</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Параллельное программирование</a>
<ul>
<li><a href="#sec-1-1">1.1. Какие-то материалы:</a></li>
<li><a href="#sec-1-2">1.2. Вступление, модели, их свойства, согласованность</a></li>
<li><a href="#sec-1-3">1.3. Блокировки, взаимное исключение, deadlock'и</a></li>
<li><a href="#sec-1-4">1.4. Алгоритмы/объекты без блокировок, свободы (lock/wait/obstr)</a></li>
<li><a href="#sec-1-5">1.5. Консенсус</a></li>
<li><a href="#sec-1-6">1.6. Практические построения на списке, вступление</a></li>
<li><a href="#sec-1-7">1.7. Типы синхронизации на примере списка (LinkedSet)</a>
<ul>
<li><a href="#sec-1-7-1">1.7.1. Грубая синхронизация</a></li>
<li><a href="#sec-1-7-2">1.7.2. Тонкая синхронизация</a></li>
<li><a href="#sec-1-7-3">1.7.3. Оптимистичная синхронизация</a></li>
<li><a href="#sec-1-7-4">1.7.4. Ленивая синхронизация</a></li>
<li><a href="#sec-1-7-5">1.7.5. Неблокирующая синхронизация</a></li>
</ul>
</li>
<li><a href="#sec-1-8">1.8. Продолжение построений на списках, стеках</a>
<ul>
<li><a href="#sec-1-8-1">1.8.1. Стек LIFO</a></li>
<li><a href="#sec-1-8-2">1.8.2. Очереди на списках, Майкл-Скотт</a></li>
<li><a href="#sec-1-8-3">1.8.3. ABA problem</a></li>
</ul>
</li>
<li><a href="#sec-1-9">1.9. Алгоритмы на массивах</a>
<ul>
<li><a href="#sec-1-9-1">1.9.1. Стек на массиве</a></li>
<li><a href="#sec-1-9-2">1.9.2. Хэш-таблицы на массиве</a></li>
</ul>
</li>
<li><a href="#sec-1-10">1.10. CASN</a></li>
<li><a href="#sec-1-11">1.11. Сложные блокировки</a></li>
<li><a href="#sec-1-12">1.12. STM</a>
<ul>
<li><a href="#sec-1-12-1">1.12.1. Транзакции с блокировкой:</a></li>
<li><a href="#sec-1-12-2">1.12.2. Транзакции без блокировки</a></li>
</ul>
</li>
<li><a href="#sec-1-13">1.13. Мониторы и локи</a></li>
<li><a href="#sec-1-14">1.14. SPSC очередь без блокировок и конвейер</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Распределенные системы</a>
<ul>
<li><a href="#sec-2-1">2.1. Билеты</a></li>
<li><a href="#sec-2-2">2.2. Вступление</a></li>
<li><a href="#sec-2-3">2.3. Глобальные состояния и срезы</a></li>
<li><a href="#sec-2-4">2.4. Диффундирующие вычисления</a></li>
<li><a href="#sec-2-5">2.5. Локальная стабильность, баръерные синхонизации</a></li>
<li><a href="#sec-2-6">2.6. Упорядочивания событий</a></li>
<li><a href="#sec-2-7">2.7. Системы, ошибки, FLP теорема</a></li>
<li><a href="#sec-2-8">2.8. Консенсус и TRB</a></li>
<li><a href="#sec-2-9">2.9. Недетерминированные алгоритмы и Бен-Ор</a></li>
<li><a href="#sec-2-10">2.10. Replicated State Machine, Paxos</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Параллельное программирование</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Какие-то материалы:</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li><a href="https://www.slideshare.net/secret/6dv9wtl1pDOTgu">https://www.slideshare.net/secret/6dv9wtl1pDOTgu</a>
</li>
<li><a href="https://www.slideshare.net/secret/h3wT59xRPciKM6">https://www.slideshare.net/secret/h3wT59xRPciKM6</a>
</li>
<li><a href="https://www.slideshare.net/secret/yDV9vtRs61gEdg">https://www.slideshare.net/secret/yDV9vtRs61gEdg</a>
</li>
<li><a href="https://www.slideshare.net/secret/E1asIyWYNfvkNv">https://www.slideshare.net/secret/E1asIyWYNfvkNv</a>
</li>
<li><a href="https://www.slideshare.net/secret/LnSxMJ7JZ25JFe">https://www.slideshare.net/secret/LnSxMJ7JZ25JFe</a>
</li>
<li>Консенсус:
<a href="https://www.slideshare.net/secret/LnSxMJ7JZ25JFe">https://www.slideshare.net/secret/LnSxMJ7JZ25JFe</a>
</li>
<li>Реализация ссылочных структуры:
<a href="https://www.slideshare.net/secret/zrtgOfnRQY6K0Z">https://www.slideshare.net/secret/zrtgOfnRQY6K0Z</a>
</li>
<li>Массивы, CASN, R/W Locks, STM:
<a href="https://www.slideshare.net/secret/8ZkekdbzRSIjsP">https://www.slideshare.net/secret/8ZkekdbzRSIjsP</a>
</li>
<li>Рекомендуемые учебники:
<ul class="org-ul">
<li>The Art of Multiprocessor Programming, Maurice Herlihy, Nir
Shavit, <a href="http://www.amazon.com/The-Multiprocessor-Programming">http://www.amazon.com/The-Multiprocessor-Programming</a>-..
Это основной учебник для осеннего семестра. Его надо знать и
любить.
</li>
<li>Concurrent and Distributed Computing in Java, Vijay K. Garg,
<a href="http://www.amazon.com/Concurrent-Distributed-Computin">http://www.amazon.com/Concurrent-Distributed-Computin</a>..  Обзор
для всех частей курса (пригодится так же и для второго
семестра).
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Вступление, модели, их свойства, согласованность</h3>
<div class="outline-text-3" id="text-1-2">
<p>
<b>SMP</b> (<i>symmetric multiprocessing</i>) &#x2013; два или больше ядра, на каждом по
потоку.
</p>

<p>
<b>SMT</b> (<i>simultaneous multithreading</i>) &#x2013; два или больше потоков
исполняются одним ядром.
</p>

<p>
<b>NUMA</b> (<i>not uniform memory access</i>) &#x2013; все знают, что это еще с 1
курса.
</p>

<p>
Операционные системы (классификация по параллельности):
</p>
<ol class="org-ol">
<li>Однозадачные
</li>
<li>Пакетные задания (<i>batch processing</i>)
</li>
<li>Многозадачные
<ol class="org-ol">
<li>Кооперативная (<i>cooperative</i>) многозадачность.
Переход от одной задачи к другой происходит явно, когда
программа готова передать процессорное время другой.
</li>
<li>Вытесняющая (<i>preemptive</i>) многозадачность.
Текущий подвид &#x2013; ОС сама расставляет инструкции как ей этого
хочется.
</li>
</ol>
</li>
</ol>

<p>
Поток и процесс (на практике вперемешку):
</p>
<ul class="org-ul">
<li><b>Процесс</b> &#x2013; владеет памятью и ресурсами.
</li>
<li><b>Поток</b> &#x2013; контекст исполнения внутри процесса.
</li>
</ul>

<p>
Модели программирования:
</p>
<ol class="org-ol">
<li>Однопоточное/однозадачное.
</li>
<li>Многозадачное:
<ol class="org-ol">
<li>Модель с общей памятью:
Единственное, что объединяет потоки &#x2013; общие объекты.
Общий объект &#x2013; переменная (<code>read/write</code>, тип). Иногда зовутся
регистрами, так как на практике значения лежат как раз в
регистрах ЦП.
</li>
<li>Модель с передачей сообщений.
</li>
</ol>
</li>
</ol>

<p>
Модели исполнения:
</p>
<ol class="org-ol">
<li>Модель чередований
Строим дерево, в котором описываем все возможные перестановки
операций над общими объектами. Такая модель не описывает
появление пары <code>(0, 0)</code> в следующем примере:

<div class="org-src-container">

<pre class="src src-text" id="java-no-volatile">thread P {
       x = 1
       r1 = y
}
thread Q {
       y = 1
       r2 = x
}
</pre>
</div>

<p>
Но оно может появиться вследствие того факта, что компилятор
может переставить инструкции или же просто запись обоих значений
будет отложена процессором.
</p>

<p>
Модель чередования не описывает конкретно физических реалий этого
мира &#x2013; ведь свет за один такт процессора проходит 10см, элементы
просто физически не могут синхронизоваться.
</p>

<p>
Физическая &#x2013; это световой конус.
</p>
</li>
<li>Happens before
Исполнение системы &#x2013; пара \(⟨H, →⟩\).
<ul class="org-ul">
<li>\(H\) &#x2013; множество операций (чтение и запись ячеек памяти)
</li>
<li>\(e → f\) значит, что \(e\) произошло раньше \(f\) &#x2013; частичный строгий
порядок на \(H\).
</li>
<li>\(a ∥ b\), если \(¬(a → b ∨ b → a)\).
</li>
</ul>
</li>
<li>Модель глобального времени
Каждая операция &#x2013; интервал \([t_{inv}, t_{resp}]\), и если выражать
через happens-before, то \(a → b ≡ t_{resp}(a) < t_{inv}(b)\).
</li>
</ol>

<p>
Конфликты:
</p>
<ul class="org-ul">
<li><b>Конфликт</b> (<i>data race</i>) &#x2013; ситуация, когда происходит две
параллельных операции, и одна из них &#x2013; запись.
</li>
<li>Корректно синхронизированная программа &#x2013; программа без
конфликтов.
</li>
</ul>

<p>
Исполнения:
</p>
<ol class="org-ol">
<li><b>Последовательное</b> &#x2013; все операции линейно упорядочены отношением
happens-before (→). В модели глобального времени ничего не
наслаивается вообще.
</li>
<li><b>Правильное</b> &#x2013; сужение исполнения на один поток (только
операции, приналежащие конкретному потоку) последовательно.
Неправильные исполнения &#x2013; вообще какая-то чепуха (параллельность
в одном потоке). Или "<code>a = (b++) + (c++)</code>" &#x2013; undefined behavior
в плюсах.
</li>
<li><b>Допустимое последовательное</b> исполнение &#x2013; выполнены
последовательные спецификации всех объектов. Посл. спецификация
объекта &#x2013; последовательность сужения исполнения на конкретный
объект.
</li>
</ol>

<p>
Условия согласованности:
</p>
<ol class="org-ol">
<li>Последовательная согласованность
Исполнение посл. согласованно, если можно сопоставить ему
допустимое последовательное исполнение, причем программный
порядок (≡ порядок операций на каждом потоке) сохраняется.

<p>
Кстати последовательная согласованность на каждом объекте не
влечет за собой последовательную согласованность исполнения.
</p>
</li>
<li>Линеаризуемость
Исполнение линеаризуемо, если можно сопоставить ему
допустимое последовательное исполнение, которое сохраняет порядок
happens-before.

<p>
Линеаризуемость локальна, линеаризуемость на каждом объекте
влечет линеаризуемость системы.
Операции над линеаризуемыми объектами называют атомарными.
Исполнение системы, выполняющее операции над линеаризуемыми
объектами, можно анализировать в модели чередования.
Свойство thread-safe объекта есть ровно линеаризуемость.
</p>

<p>
Если в примере java-novolatile сделать <code>x,y volatile</code>, то пара
\((0,0)\) не будет появляться, то есть исполнение действительно
соответствует модели чередования.
</p>

<p>
Реализуется <code>volatile</code> в java локами памяти (<i>memory lock</i>). Тут
мы немного теряем производительность, но не страшно.
</p>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Блокировки, взаимное исключение, deadlock'и</h3>
<div class="outline-text-3" id="text-1-3">
<p>
<b>Линеаризуемость</b> &#x2013; суперское свойство.  Даже если в каждом потоке
все операции атомарны, мы не можем утверждать, что объект
линеаризуем (ну представьте себе класс очереди с методами
<code>push/pop</code>).  Мы вот хотим линеаризуемую очередь.
</p>

<p>
Самый простой метод сделать так &#x2013; это использование блокировок
(<i>locks</i>, <i>mutex</i> (<i>mutual exclusion</i>)).
</p>

<p>
Идея: заведем в объекте <code>member Mutex m</code>, будем его лочить и
разлочивать. Этот объект будет гарантировать, что объект будет
застрявать на <code>.lock</code>, если мьютекс уже залочен и т.д.  Код с
mutex'ами будет thread-safe, если операции будут защищены одним и
тем же мьютексом.
</p>

<ul class="org-ul">
<li><b>Взаимное исключения</b> &#x2013; свойство исполнения, при котором
критические секции не могут выполняться параллельно &#x2013; это
требование корректности взаимного исключения.
</li>
</ul>

<p>
При этом взаимное исключение имеет ряд условных условий прогресса:
</p>
<ol class="org-ol">
<li><b>Свобода взаимной блокировки</b> (<i>deadlock-freedom</i>) &#x2013; свойство
взаимного исключения, при котором если несколько потоков
пытаются войти в критическую секцию, то хотя бы один сделает
это за конечное время (при условии что критические секции сами
по себе конечны).
</li>
<li><b>Отсутствие голодания</b> (<i>starvation-freedom</i>) &#x2013; если какой-то
поток пытается войти в критическую секцию, он сделает это за
конечное время (опять-таки, при условии, что крит. секции
исп. за конечное время).
</li>
<li><b>Линейное ожидание</b> &#x2013; каждый поток совершает \(O(n)\) действий
перед тем, как войти в критическую секцию (условие аналогично)
</li>
<li><b>First Come First Served</b> (<i>FSFS</i>) &#x2013; свойство сильнее
линейного ожидания, потоки обслуживаются в порядке утыкания в
критическую секцию (условие аналогично).
</li>
</ol>

<p>
Как написать mutex, собственно?
</p>
<ol class="org-ol">
<li><b>Aлгоритм Петерсона</b> &#x2013; гарантирует взаимное исключение,
отсутствие взаимной блокировки и отсутствие голодания.

<p>
Преимущество &#x2013; самый простой.
</p>
<div class="org-src-container">

<pre class="src src-text">threadlocal int id // 0 or 1
shared boolean want[2]
shared int     victim

def lock:
    want[id] = true
    victim = id
    while (want[1-id] and victim == id) {}

def unlock:
    want[id] = false
</pre>
</div>
</li>
<li><b>Aлгоритм Петерсона для N потоков</b> (<i>filter algorithm</i>).

<p>
Все то же самое, но может делать \(O(N²)\) ожидания.
</p>
<div class="org-src-container">

<pre class="src src-text">threadlocal int id
shared int level[N]
shared int victim[N]

def lock:
    for j = 1..N-1:
        level[id] = j
        victim[j] = id
        while exist k: k != id and
                       level[k] &gt;= j and
                       victim[j] == id:
                       {}

def unlock:
    level[id] = 0
</pre>
</div>
</li>
<li>Алгоритм <b>Лампорта</b> (булочника &#x2013; 1 вариант).  Обладает свойством
FCFS. Это вариант с бесконечными метками <code>label</code>. Можно сделать с
конечными.

<p>
Первые две строки <code>lock</code> называются <code>doorway</code>.
</p>
<div class="org-src-container">

<pre class="src src-text">threadlocal int id
shared boolean want[N]  // init false
shared int     label[N] // init 0

def lock:
    want[id] = true
    label[id] = max(label) + 1
    while exists k: k != id and
                    want[k] and
                    (label[k], k) &lt; (label[id], id)
                    {}
</pre>
</div>
</li>
</ol>

<p>
Блокировки бывают грубыми и тонкими.
</p>
<ul class="org-ul">
<li><b>Грубая</b> &#x2013; блокировать всю операцию целиком.
</li>
<li><b>Тонкая</b> &#x2013; блокировать операции над общими объектами внутри, а не
вызов, но тогда необходима двухфазовая блокировка.
</li>
</ul>

<p>
Есть проблема deadlock'а. Допустим, что есть два mutex'а, мы лочимся
в одном треде сначала по <code>m1</code>, потом по <code>m2</code>, в другом треде
наоборот. Можем задедлочиться тут короче.
</p>

<p>
<b>Закон Амдала</b> для параллельной работы: \[speedup = \frac{1}{(S +
   \frac{1-S}{N})}\] Это максимальное ускорение при запуске кода в \(N\)
потоков, если доля кода \(S\) выполнена последовательно.
</p>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> Алгоритмы/объекты без блокировок, свободы (lock/wait/obstr)</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Алгоритмы без блокировок.
</p>

<p>
Безусловные условия прогресса:
</p>
<ol class="org-ol">
<li><b>Obstruction-free</b> (<i>отсутствие помех</i>) &#x2013; свойство алгоритма, в
котором если остановить всe потоки кроме одного (любого) в любом
месте, один должен завершиться за конечное время. Так должно
работать для каждого объекта.  Очевидно, что объект с блокировкой
не имеет такого свойства.
</li>
<li><b>Lock-freedom</b> &#x2013; если много потоков пытаются сделать операцию,
то хотя бы один поток должен ее исполнить за конечное
время. Плохо то, что это условие не исключает голодания.
</li>
<li><b>Wait-freedom</b> (самое сильное условие) &#x2013; если какой-то поток
пытается выполнить операцию, то он это сделает (вне зависимости
от действия/бездействия других потоков).
</li>
</ol>

<p>
Объекты без блокировки. ОБъекты бывают с lock-freedom, но этот
термин перегружен.
</p>
<ul class="org-ul">
<li>Регистры без блокировки
<ul class="org-ul">
<li>Свойства физических регистров:
<ol class="org-ol">
<li>Неатомарны.
</li>
<li>Работают без ожидания.
</li>
<li>Предполагают только одного читателя и одного писателя.
</li>
<li>Попытка записать и прочитать одновременно &#x2013; UB.
</li>
<li>Они безопасные (<i>safe</i>) &#x2013; в смысле, после записи, будет
прочитано последнее записанное значение.
</li>
</ol>
</li>
<li>Классификация регистров
<ol class="org-ol">
<li>По условиям согласованности:
<ol class="org-ol">
<li><b>Безопасные</b> (<i>safe</i>) &#x2013; гарантирует получение последнего
записанного значения, если операция чтения не параллельна
операции записи.
</li>
<li><b>Регулярные</b> (<i>regular</i>) &#x2013; при чтении выдает последнее
записанное, или то, что уже пишется.
</li>
<li><b>Атомарные</b> (<i>atomic</i>) &#x2013; линеаризуемое (как регулярный,
только если уже прочитал новое значение, то старое нельзя
прочитать).

<p>
Как проверить регистр на атомарность в схеме глобального
времени &#x2013; поставить в каждой полоске точку,
соответствующую этому конкретному действию. Порядок по
точкам должен быть атомаррным.
</p>
</li>
</ol>
</li>
<li>По количеству потоков (<code>SR</code>, <code>MR</code>, <code>SW</code>, <code>MW</code> :
<code>single/multi</code> <code>reader/writer</code>).
</li>
</ol>
</li>

<li>Будем строить более сложные регистры из простых требуя
wait-free условие.
Пусть у нас есть Safe SRSW Boolean регистр.
<ol class="org-ol">
<li>Regular SRSW Boolean.

<div class="org-src-container">

<pre class="src src-text">safe shared boolean r
threadlocal boolean last

def write(x):
  if (x != last)
    last = x
    r = x

def read(): return r
</pre>
</div>
</li>
<li>Regular SRSW M-Valued.

<p>
Пусть у нас массив <code>r</code> хранит булевые значения, и число в нем
хранится последовательностью единиц, терминированной
нулем. Тогда это реализуется так:
</p>

<div class="org-src-container">

<pre class="src src-text">regular shared boolean[M] r

def write(x): // &#1057;&#1087;&#1088;&#1072;&#1074;&#1072; &#1085;&#1072;&#1083;&#1077;&#1074;&#1086;
  r[x] = 0
  for i = x-1 downto 0: r[i] = 1

def read(): // &#1057;&#1083;&#1077;&#1074;&#1072; &#1085;&#1072;&#1087;&#1088;&#1072;&#1074;&#1086;
  for i = 0 to M-1: if r[i] == 0: return i
</pre>
</div>
</li>
<li>Atomic SRSW M-Valued.

<p>
Будем хранить пару &#x2013; значение и версию. Версию можно разумно
ограничить. Есть алгоритм без жульничества с версиями, но он
на практике плох.
</p>

<div class="org-src-container">

<pre class="src src-text">safe shared (int x, int v) r
threadlocal (int x, int v) lastRead
threadlocal int lastWriteV

def write(x):
  lastWriteV++
  r = (x, lastWriteV)

def read():
  cur = r
  if cur.v &gt; lastRead.v:
    lastRead = cur
  return lastRead.x
</pre>
</div>

<p>
Атомарный регистр: проблемы
</p>
<ol class="org-ol">
<li><b>Версии</b> &#x2013; могут хранить пару в регуярном, но версии
растут неограниченно.
</li>
<li><b>Блокировки</b> &#x2013; алгоритм Лампорта будет работать на
регулярных регистрах, но это не дает алгоритм без ожидания.
</li>

<li>Теорема: не существует алгоритма построения атомарного
регистра без ожидания, который использует конечное число
регулярных регистров конечного размера так, чтобы их писал
только писатель, а читал только читатель
</li>
<li>Доказательство
Нужна обратная связь от читателя к писателю.
</li>
</ol>
</li>
<li>Atomic MRSW M-Valued.

<p>
Нужно отслеживать версию записанного значения, храня пару
\((x, v)\) в каждом из \(N\) регистров в которые пишет писатель.
Наивно сделать это нельзя.
</p>

<p>
Заведем \(N×(N-1)\) регистров для общения между читателями.
</p>

<ol class="org-ol">
<li>Каждый читатель выбирает более позднее значение из
записанного писателем и из прочитанных значенией других
читателей
</li>
<li>Читатель записывает свое прочитанное значение и версию для
всех остальных читателей.
</li>
</ol>
</li>
<li>Atomic MRMW M-Valued.

<p>
Нужна поддержка \(N\) писателей.
</p>

<p>
Отслеживаем версию записанного значения:
</p>
<ol class="org-ol">
<li>Каждый читатель выбирает более позднюю версию
</li>
<li>Для проставления версий писателями используем doorway
секцию из алгоритма булочника (Лампорта)
<ul class="org-ul">
<li>Версия состоит из пары номера потока писателя и
собственно числа
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li>Атомарный снимок состояния N регистров.

<p>
Наивная реализация не обеспечивает атомарность.
</p>

<p>
Вот этот алгоритм уже lock-free, но достаточно наивный &#x2013;
читает, пока массивы не совпадут.
</p>
<div class="org-src-container">

<pre class="src src-text" id="lock-free-implementation-of-atomic-registers-snapshot">shared (int x, int v) r[N]

// wait-free
def update(i, x):
    r[i] = (x, r[i].v + 1)

// lock-free
def scan():
    old = copy()
    loop:
        cur = copy()
        if forall i: cur[i].v == old[i].v
           return cur.x  // we can get starvation here,
                         // if update is executed too frequent
        old = cur
</pre>
</div>

<p>
Вот wait-free реализация с костылями.
</p>
<div class="org-src-container">

<pre class="src src-text" id="wait-free-implementation">shared (int x, int v, int[N] s) r[N]

def update():
    s = scan()
    r[i] = (x, r[i].v + 1, s)

shared (int x, int v, int[N] s) r[N]

// wait-free, O(N^2)
def scan():
    old = copy()
    boolean updated[N]
    loop:
        cur = copy()
        for i = 0..N-1:
            if cur[i].v != old[i].v:
               if updated[i]: return cur.s
               else:
                update[i] = true
                old = cur
                continue loop
        return cur.x
</pre>
</div>
<ul class="org-ul">
<li>Лемма: Если значение поменялось второй раз, значит копия
снимка \(s\) была получена вложенной операцией <code>scan</code>.
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> Консенсус</h3>
<div class="outline-text-3" id="text-1-5">
<p>
<b>Консенсус</b> &#x2013; это объект, который помогает \(n\) потокам придти к общему
мнению.
</p>
<div class="org-src-container">

<pre class="src src-text">class Consensus:
      def decide(val):
      ...
      return decision
</pre>
</div>

<p>
Каждый поток использует объект <code>Consensus</code> один раз.
Требуются две вещи:
</p>
<ul class="org-ul">
<li><b>Согласованность</b> (<i>consistency</i>): все потоки должны вернуть одно
и то же значение из метода decide.
</li>
<li><b>Обоснованность</b> (<i>validity</i>): возвращенное значение было входным
значением какого-то из потоков.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-text" id="">shared int decision
Mutex mutex

def decide(val):
    mutex.lock()
    if (decision == NA):
       decision = val
    mutex.unlock()
    return decision
</pre>
</div>
<p>
Но мы хотим без ожидания.
</p>

<p>
Все не так просто.
Консенсусное число:
</p>
<ol class="org-ol">
<li>Если с помощью класса атомарных объектов \(С\) и атомарных регистров
можно реализовать консенсусный протокол без ожидания для \(N\)
потоков (и не больше), то говорят что у класса \(С\) консенсусное
число равно \(N\).
</li>
<li>Теорема:
Атомарные регистры имеют консенсусное число 1.
<ul class="org-ul">
<li>То есть с помощью атомарных регистров даже 2 потока не могут
придти к консенсусу без ожидания (докажем от противного) для 2х
возможных значений при \(T = \{0, 1\}\)
</li>
<li>С ожиданием задача решается очевидно (с помощью любого
алгоритма взаимного исключения).
</li>
</ul>
</li>
<li>Определения и леммы для любых классов объектов:
<ul class="org-ul">
<li>Определения и концепции
<ol class="org-ol">
<li>Исходныe объекты атомарны. Любое исполнение можно
рассматривать как последовательное в каком-то порядке.
</li>
<li>Рассматриваем дерево состояния, листья &#x2013; конечные состояния
помеченные 0 или 1 (в зависимости от значения консенсуса).
</li>
<li><b>x-валентное</b> состояние системы (\(x ∈ \{0,1\}\)) &#x2013; консенсус
по всех нижестоящих листьях будет x.
</li>
<li><b>Бивалентное</b> состояние &#x2013; возможен консенсус как 0 так и 1.
</li>
<li><b>Критическое</b> состояние &#x2013; такое бивалентное состояние, все
дети которого одновалентны.
</li>
</ol>
</li>
<li>Лемма: Существует начальное бивалентное состояние.

<p>
Это нетривиально следует из того факта, что алгоритм без
ожиданий.
</p>

<p>
Возьмем конечное количество шагов, построим дерево.
\(???\)
Доказательство было на доске и не сохранилось.
</p>
</li>
<li>Лемма: Существует критическое состояние

<p>
Тоже следует из wait-free. Если есть бивалентное, будем
смотреть его детей. Если есть хотя бы один бивалентный ребенок,
то спускаемся в него, пока бивалентных детей больше нету.
За счет конечности дерева такое будет существовать, и
валентность детей будет различна (иначе валентность самого узла
тоже определена).
</p>
</li>
</ul>
<p>
Для атомарных регистров рассмотрим возможные пары операций в
критическом состоянии:
</p>
<ul class="org-ul">
<li>Операции над разными регистрами коммутируют.
</li>
<li>Два чтения коммутируют.
</li>
<li>Любая операция + запись &#x2013; состояние пишущего потока не зависит
от порядка операций. Противоречие (в чем???).
</li>
</ul>
</li>
<li>Бывают Read-Modify-Write регистры.

<div class="org-src-container">

<pre class="src src-text" id="read-modify-write-reg">class RMWRegister:
      private shared int reg

      def read():
          return reg

      def getAndF(args):
          do atomically:
             old = reg
             reg = F(args)(reg)
             return old
</pre>
</div>
<p>
Функция F может быть <code>getAndSet</code>, <code>getAndIncrement</code>,&#x2026;
</p>

<div class="org-src-container">

<pre class="src src-text" id="Consensus-for-RMW-reg-2">threadlocal int id // 0 or 1

shared RMWRegister rmw
shared int proposed[2]

def decide(val):
    proposed[id] = val
    if (rmw.getAndF() == v0)
        return proposed[i]
    else:
        return proposed[1-i]
</pre>
</div>

<ul class="org-ul">
<li>Консенсусное число нетривиального RMW регистра \(≥ 2\).

<p>
Нужно чтобы была хотя бы одна подвижная точка функции \(F\),
например \(F(v_0) = v_1 ≠ v_0\).
</p>
</li>
</ul>
</li>

<li>Common2 RMW регистры
<ul class="org-ul">
<li>\(F_1\) и \(F_2\) коммутируют если \(F_1(F_2(x)) = F_2(F_1(x))\).
</li>
<li>\(F_1\) перезаписывает \(F_2\) если \(F_1(F_2(x)) = F_1(x)\).
</li>
<li>Класс \(С\) RMW регистров принадлежит Common2 если любая пара
функций либо коммутирует либо одна из функций перезаписывает
другую.
</li>
<li>Теорема: нетривиальный класс Common2 RMW регистров имеет
консенсусное число 2.

<p>
Третий поток не может отличить глобальное состояние при
изменении порядка выполнения коммутирующих или перезаписывающих
операций в критическом состоянии.
</p>
</li>
</ul>
</li>
<li>Универсальные объекты
Объект с консенсусным числом \(∞\) называется универсальным объектом.
По определению, с его помощью можно реализовать консенсусный
протокол для любого числа потоков.

<div class="org-src-container">

<pre class="src src-text" id="CAS-register">class CASRegister:
      private shared int reg

      def CAS(expect, update):
          do atomically:
             old = reg
             if old == expect:
                reg = update
                return true
             return false
</pre>
</div>

<p>
CAS &#x2013; самый популярный универсальный объект, процессоры в том
или ином виде его реализуют.
</p>

<ul class="org-ul">
<li>CAS и консенсус
<div class="org-src-container">

<pre class="src src-text" id="CAS-READ">def decide(val):
    if CAS(NA, val):
        return val
    else:
        return read()
</pre>
</div>
</li>

<li>Универсальность консенсуса. Теорема.
Любой последовательый объект можно реализовать без ожидания для
N потоков используя консенсусный протокол для N объектов

<ul class="org-ul">
<li>Такое построение &#x2013; универсальная конструкция
</li>
<li>Следствие 1: С помощью любого класса объектов с консенсусным
числом N можно реализовать любой объект с консенсусным числом
≤ N
</li>
<li>Следствие 2: С помощью универсального объекта можно
реализовать вообще любой объект
<ul class="org-ul">
<li>Сначала реализуем консенсус для любого числа потоков (по
определению универсального объекта)
</li>
<li>Потом через консенсус любой другой объект используя
универсальную конструкцию.
</li>
</ul>
</li>
<li>Доказательство теоремы
<ol class="org-ol">
<li>Универсальная конструкция без блокировки через CAS
<div class="org-src-container">

<pre class="src src-text">shared CASRegister reg

def concurrentOperationX(args):
    loop:
        old = reg.read()
        upd = old.deepCopy()
        res = upd.serialOperationX(args)
    until reg.CAS(old, upd)
    return res
</pre>
</div>

<ul class="org-ul">
<li>Без блокировки универсальная конструкция проста и
проктична, если использовать CAS в качестве примитива.
</li>
<li>Для реализации через консенсус надо чтобы каждый объект
консенсуса пользовался потоком один раз
</li>
<li>Для реализации без ожидания нужно чтобы потоки помогали
друг другу.
</li>
</ul>
</li>
<li>Через консенсус.

<p>
ОБъект &#x2013; односвязный список стейтов.
Последний элемент &#x2013; текущий стейт.
</p>

<div class="org-src-container">

<pre class="src src-text" id="">class Node:
      val               // readonly
      Consensus next    // init fresh obj

shared Node root        // readonly
threadlocal Node last   // init rood

def concurrentOperationX(args):
    loop:
        old = last.val
        upd = old.deepCopy()
        res = upd.serialOperationX(args)
        node = new Node(upd)
        last = last.next.decide(node)
    until last == node
    return res
</pre>
</div>

<ul class="org-ul">
<li>Но с ожиданием
</li>
</ul>
</li>

<li>Через консенсус без ожидания
<ul class="org-ul">
<li>Храним в узле операцию, которую нужно выполнить, а не
результат &#x2013; каждый поток обновляет и хранит свою
локальную копию объекта
</li>
<li>Нумеруем операции последовательными числами, заведя
переменную <code>seq</code>. После выполнения прописываем номер
исполненной операции.
</li>
<li>Каждй поток хранит последнее ему известное значение
конца списка в элементе массива <code>know[id]</code>.
</li>
<li>Каждый поток будет заранее записывать операцию, которую
он планирует выполнить &#x2013; в массиве <code>announce</code>.
</li>
</ul>
<div class="org-src-container">

<pre class="src src-text" id="">class Node:
      int seq           // init 0
      args              // readonly
      Consensus next    // init fresh obj

shared Node[] announce // init root
shared Node[] know // init root

def concunrrentOperationX(args):
    announce[id] = new Node(args)
    know[id] = maxSeqFrom(know)
    while announce[id].seq == 0
          Node help =
               announce[know[id].seq % N]
          Node prev = help if help.seq == 0
               else announce[id]
          know[id] = prev.next.decide(node)
          know[id].seq = prev.seq + 1
    know[id] = announce[id]
    return updateMyLastTo(announce[id])

def updateMyLastTo(node):
    while last != node:
          res = my.serialOperationX(last.args)
          last = last.next
          return res
</pre>
</div>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>Сводная иерархия
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Объект</th>
<th scope="col" class="right">Консенсусное число</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">Атомарные регистры</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">Снимок состояния нескольких регистров</td>
<td class="right">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">getAndSet, getAndAdd, очередь, стек</td>
<td class="right">2</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">Атомарная запись m регистров из m(m+1)/2</td>
<td class="right">m</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">compareAndSet, LoadLinked/StoreConditional</td>
<td class="right">∞</td>
</tr>
</tbody>
</table>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> Практические построения на списке, вступление</h3>
<div class="outline-text-3" id="text-1-6">
<p>
Будем смотреть всякие практические построения на списках.
Будем писать код уже на джаве настоящей.
</p>

<p>
<b>Java</b> &#x2013; первый язык, в котором появилась модель памяти (<i>memory
model</i>). Почему джава? Трюки c++ (<code>if_arch_</code>&#x2026;) не работают в джаве,
джава очень WORA, и прочее.
</p>

<p>
<b>JMM</b> определяет:
</p>
<ol class="org-ol">
<li>Межпоточные действия &#x2013; чтение и запись,
синхронизация. Синхронизация &#x2013; ~volatile~/~synchronized~/запуск или
остановка потоков.
</li>
<li>Отношение синхронизации (<i>synchronizes-with</i>) и отношение
happens-before.
Java гарантирует, что если в программе нету гонок, то исполнение
последовательно согласовано (а значит и линеаризуемо).
</li>
<li>Всякие гонки и прочее.
</li>
</ol>

<p>
Выполнение корректно синхронизированной программы будет выглядеть
последовательно согласовано. Гонки за данными не могут нарушить
базовые гарантии безопасности платформы (система типов, все кроме
<code>long/double</code> атомарны, все поля гарантированно инициализированы
нулями, дополнительные гарантии для <code>final</code> полей).
</p>

<div class="org-src-container">

<pre class="src src-java" id="1-volatile"><span style="color: #FFA070;">volatile</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">flag</span>;
<span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">value</span>;

<span style="color: #EF5C5F;">void</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">int</span>()<span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span>value<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>2;
<span style="color: #333333;">    </span>flag<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>1;
}

<span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">take</span>()<span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(flag<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>0);<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1082;&#1091;&#1096;&#1072;&#1077;&#1084;</span><span style="color: #333333;"> </span><span style="color: #637579;">cpu</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1090;&#1091;&#1090;</span>
<span style="color: #333333;">    </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>value;
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-java" id="2-cpu"><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">flag</span>,<span style="color: #333333;"> </span><span style="color: #A197BF;">value</span>;

<span style="color: #EF5C5F;">void</span><span style="color: #333333;"> </span><span style="color: #FFA070;">synchronized</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">int</span>()<span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span>value<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>2;
<span style="color: #333333;">    </span>flag<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>1;
}

<span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #FFA070;">synchronized</span><span style="color: #333333;"> </span>take()<span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(flag<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>0);<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1082;&#1091;&#1096;&#1072;&#1077;&#1084;</span><span style="color: #333333;"> </span><span style="color: #637579;">cpu</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1090;&#1091;&#1090;</span>
<span style="color: #333333;">    </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>value;
}
</pre>
</div>

<p>
Таким образом, мы реализовали thread-safe объект.
</p>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> Типы синхронизации на примере списка (LinkedSet)</h3>
<div class="outline-text-3" id="text-1-7">
<ul class="org-ul">
<li><b>Многопоточные объект</b> &#x2013; это объект, который можно использовать
из нескольких потоков без дополнительной внешней синхронизации,
при этом:
<ol class="org-ol">
<li>Специфицируется через последовательное поведение.
</li>
<li>По умолчанию требуется линеаризуемость операций (редко &#x2013; более
слабые условия).
</li>
<li>Редко удается реализовать все операции wait-free. Чаще всего
делается с блокировками или без них (что на самом деле
lock-free).
</li>
</ol>
</li>
</ul>

<p>
Типы синхронизации:
</p>
<ol class="org-ol">
<li>Грубая синронизация (<code>Coarse-grained</code>).
</li>
<li>Тонкая (<code>fine-grained</code>).
</li>
<li>Оптимистичная (<code>optimistic</code>).
</li>
<li>Ленивая (<code>lazy</code>).
</li>
<li>Неблокирующая (<code>non-blocking</code>).
</li>
</ol>

<p>
Будем строить многопоточные связанные списки. Массивами пользоваться
намного эффективней, но они сложнее пишутся.
</p>

<div class="org-src-container">

<pre class="src src-java" id=""><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1080;&#1085;&#1074;&#1072;&#1088;&#1080;&#1072;&#1085;&#1090;</span><span style="color: #333333;"> </span><span style="color: #637579;">node.key</span><span style="color: #333333;"> </span><span style="color: #637579;">&lt;</span><span style="color: #333333;"> </span><span style="color: #637579;">node.next.key</span>
<span style="color: #FFA070;">class</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">key</span>;
<span style="color: #333333;">    </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">item</span>;
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">next</span>;
}
</pre>
</div>
<p>
Пустой список будет состоять из 2х граничных элементов:
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">head</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>Node(<span style="color: #6F8FCC;">Integer</span>.MIN_VALUE,<span style="color: #333333;"> </span><span style="color: #6F8FCC;">null</span>);
head.next<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>Node(<span style="color: #6F8FCC;">Integer</span>.MAX_VALUE,<span style="color: #333333;"> </span><span style="color: #6F8FCC;">null</span>);
</pre>
</div>
</div>
<div id="outline-container-sec-1-7-1" class="outline-4">
<h4 id="sec-1-7-1"><span class="section-number-4">1.7.1</span> Грубая синхронизация</h4>
<div class="outline-text-4" id="text-1-7-1">
<p>
Обеспечиваем синхронизацию через
<code>java.util.concurrent.locks.ReentrantLock lock</code>.
Такой подход дает немножко больше функционала чем секции
<code>synchronized</code>.
</p>

<div class="org-src-container">

<pre class="src src-java" id=""><span style="color: #FFA070;">class</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">LinkedSet</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">head</span>;
<span style="color: #333333;">    </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Lock</span><span style="color: #333333;"> </span><span style="color: #A197BF;">lock</span>;<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">mutex</span>

<span style="color: #333333;">    </span><span style="color: #EF5C5F;">boolean</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">contains</span>(<span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">key</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span>lock.lock();
<span style="color: #333333;">        </span><span style="color: #FFA070;">try</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">            </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">curr</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>head;
<span style="color: #333333;">            </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(curr.key<span style="color: #333333;"> </span>&lt;<span style="color: #333333;"> </span><span style="color: #EF5C5F;">key</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">                </span>curr<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>curr.next;
<span style="color: #333333;">            </span>}
<span style="color: #333333;">            </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>key<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>curr.key;
<span style="color: #333333;">        </span>}<span style="color: #333333;"> </span><span style="color: #FFA070;">finally</span><span style="color: #333333;"> </span>{<span style="color: #333333;"> </span>lock.unlock()<span style="color: #333333;"> </span>}
<span style="color: #333333;">    </span>}

<span style="color: #333333;">    </span><span style="color: #EF5C5F;">boolean</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">add</span>(<span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">key</span>,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">item</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span>lock.lock();
<span style="color: #333333;">        </span><span style="color: #FFA070;">try</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">            </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">pred</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>head,<span style="color: #333333;"> </span><span style="color: #A197BF;">curr</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>pred.next;
<span style="color: #333333;">            </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(...)<span style="color: #333333;"> </span>{}
<span style="color: #333333;">                </span><span style="color: #637579;">///</span><span style="color: #333333;"> </span><span style="color: #637579;">stuff</span>
<span style="color: #333333;">        </span>}<span style="color: #333333;"> </span><span style="color: #FFA070;">finally</span><span style="color: #333333;"> </span>{<span style="color: #333333;"> </span>lock.unlock();<span style="color: #333333;"> </span>}
<span style="color: #333333;">    </span>}
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">boolean</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">remove</span><span style="color: #333333;"> </span>(<span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">key</span>,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">item</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span>lock.lock();
<span style="color: #333333;">        </span><span style="color: #FFA070;">try</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">            </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">stuff</span>
<span style="color: #333333;">        </span>}<span style="color: #333333;"> </span><span style="color: #FFA070;">finally</span><span style="color: #333333;"> </span>{<span style="color: #333333;"> </span>lock.unlock;<span style="color: #333333;"> </span>}
<span style="color: #333333;">    </span>}
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-7-2" class="outline-4">
<h4 id="sec-1-7-2"><span class="section-number-4">1.7.2</span> Тонкая синхронизация</h4>
<div class="outline-text-4" id="text-1-7-2">
<p>
Обеспечиваем синхроизацию взаимным исключением на каждом
объекте. При любых операциях одновременно удерживаем блокировку
текущего и предыдущего элемента, чтобы не потерять инвариант
<code>pred.next == curr</code>.
</p>

<div class="org-src-container">

<pre class="src src-java" id=""><span style="color: #FFA070;">class</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">key</span>;
<span style="color: #333333;">    </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">item</span>;
<span style="color: #333333;">    </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Lock</span><span style="color: #333333;"> </span><span style="color: #A197BF;">lock</span>;
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">next</span>;

<span style="color: #333333;">    </span><span style="color: #EF5C5F;">void</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">lock</span>()<span style="color: #333333;"> </span>{<span style="color: #333333;"> </span>lock.lock();<span style="color: #333333;"> </span>}
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">void</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">unlock</span>()<span style="color: #333333;"> </span>{<span style="color: #333333;"> </span>lock.unlock();<span style="color: #333333;"> </span>}
}

<span style="color: #FFA070;">class</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">LinkedSet</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">boolean</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">contains</span>()<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">pred</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>head;<span style="color: #333333;"> </span>pred.lock();
<span style="color: #333333;">        </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">curr</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>pred.next;<span style="color: #333333;"> </span>curr.lock();
<span style="color: #333333;">        </span><span style="color: #FFA070;">try</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">            </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(curr.key<span style="color: #333333;"> </span>&lt;<span style="color: #333333;"> </span><span style="color: #EF5C5F;">key</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">                </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1090;&#1087;&#1091;&#1089;&#1082;&#1072;&#1077;&#1084;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1073;&#1083;&#1086;&#1082;&#1080;&#1088;&#1086;&#1074;&#1082;&#1091;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1091;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1088;&#1077;&#1076;&#1099;&#1076;&#1091;&#1097;&#1077;&#1075;&#1086;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1073;&#1098;&#1077;&#1082;&#1090;&#1072;</span>
<span style="color: #333333;">                </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1073;&#1077;&#1088;&#1077;&#1084;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1091;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1089;&#1083;&#1077;&#1076;&#1091;&#1102;&#1097;&#1077;&#1075;&#1086;.</span>
<span style="color: #333333;">                </span>pred.unlock();
<span style="color: #333333;">                </span>pred<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>curr;
<span style="color: #333333;">                </span>curr<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>curr.next;
<span style="color: #333333;">                </span>curr.lock();
<span style="color: #333333;">            </span>}
<span style="color: #333333;">            </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>key<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>curr.key;
<span style="color: #333333;">        </span>}<span style="color: #333333;"> </span><span style="color: #FFA070;">finally</span><span style="color: #333333;"> </span>{<span style="color: #333333;"> </span>curr.unlock();<span style="color: #333333;"> </span>pred.unlock();<span style="color: #333333;"> </span>}
<span style="color: #333333;">    </span>}

<span style="color: #333333;">    </span><span style="color: #EF5C5F;">boolean</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">add</span>(<span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">key</span>,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">item</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">pred</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>head;<span style="color: #333333;"> </span>pred.lock();
<span style="color: #333333;">        </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">curr</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>pred.next;<span style="color: #333333;"> </span>curr.lock();
<span style="color: #333333;">        </span><span style="color: #FFA070;">try</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">            </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">addition</span>
<span style="color: #333333;">            </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(curr.key<span style="color: #333333;"> </span>&lt;<span style="color: #333333;"> </span><span style="color: #EF5C5F;">key</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">                </span>pred.unlock();<span style="color: #333333;"> </span>pred<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>curr;
<span style="color: #333333;">                </span>curr<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>curr.next;<span style="color: #333333;"> </span>curr.lock();
<span style="color: #333333;">            </span>}
<span style="color: #333333;">            </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(key<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>curr.key)<span style="color: #333333;"> </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span><span style="color: #6F8FCC;">false</span>;<span style="color: #333333;"> </span><span style="color: #FFA070;">else</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">                </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">node</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span><span style="color: #FFA070;">new</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Node</span>(key,<span style="color: #333333;"> </span>item);
<span style="color: #333333;">                </span>node.next<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>curr;<span style="color: #333333;"> </span>pred.next<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>node;
<span style="color: #333333;">                </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span><span style="color: #6F8FCC;">true</span>;
<span style="color: #333333;">            </span>}
<span style="color: #333333;">        </span>}<span style="color: #333333;"> </span><span style="color: #FFA070;">finally</span><span style="color: #333333;"> </span>{<span style="color: #333333;"> </span>curr.unlock;<span style="color: #333333;"> </span>pred.unlock;<span style="color: #333333;"> </span>}
<span style="color: #333333;">    </span>}

<span style="color: #333333;">    </span><span style="color: #EF5C5F;">boolean</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">remove</span>(<span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">key</span>,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">item</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">pred</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>head;<span style="color: #333333;"> </span>pred.lock();
<span style="color: #333333;">        </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">curr</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>pred.next;<span style="color: #333333;"> </span>curr.lock();
<span style="color: #333333;">        </span><span style="color: #FFA070;">try</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">            </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">removal</span>
<span style="color: #333333;">        </span>}<span style="color: #333333;"> </span><span style="color: #FFA070;">finally</span><span style="color: #333333;"> </span>{<span style="color: #333333;"> </span>curr.unlock;<span style="color: #333333;"> </span>pred.unlock;<span style="color: #333333;"> </span>}

<span style="color: #333333;">    </span>}
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-7-3" class="outline-4">
<h4 id="sec-1-7-3"><span class="section-number-4">1.7.3</span> Оптимистичная синхронизация</h4>
<div class="outline-text-4" id="text-1-7-3">
<p>
Алгоритм построения:
</p>
<ol class="org-ol">
<li>Ищем элемент без синхронизации, но перепроверяем с
синхронизацией.
<ol class="org-ol">
<li>Если перепроверка сломалась, то начинаем операцию заново
</li>
<li>Поиск не зациклится, ибо ключи упорядочены, никогда не
меняются внутри Node, значения next не могут возникнуть
ниоткуда даже при чтении без синхронизации
</li>
</ol>
</li>
<li>Имеет смысл только если обход дешев и быстр, а обход с
синхронизацией &#x2013; наоборот.
</li>
<li>Потоки всегда синхронизируются между собой ("synchronizes with")
через критические секции, поэтому никаких дополнительных
механизмов не нужно.
</li>
</ol>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #FFA070;">class</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">LinkedSet</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1088;&#1086;&#1074;&#1077;&#1088;&#1103;&#1077;&#1090;,</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1095;&#1090;&#1086;</span><span style="color: #333333;"> </span><span style="color: #637579;">pred</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1103;&#1074;&#1083;&#1103;&#1077;&#1090;&#1089;&#1103;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1088;&#1077;&#1076;&#1099;&#1076;&#1091;&#1097;&#1080;&#1084;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1076;&#1083;&#1103;</span><span style="color: #333333;"> </span><span style="color: #637579;">curr</span>
<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1080;&#1076;&#1077;&#1090;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1090;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1085;&#1072;&#1095;&#1072;&#1083;&#1072;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1089;&#1087;&#1080;&#1089;&#1082;&#1072;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1076;&#1086;</span><span style="color: #333333;"> </span><span style="color: #637579;">pred</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1087;&#1090;&#1080;&#1084;&#1080;&#1089;&#1090;&#1080;&#1095;&#1085;&#1086;,</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1090;&#1072;&#1084;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1089;&#1088;&#1072;&#1074;&#1085;&#1080;&#1074;&#1072;&#1077;&#1090;</span>
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">boolean</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">validate</span>(<span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">pred</span>,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">curr</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">node</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>head;
<span style="color: #333333;">        </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(node.key<span style="color: #333333;"> </span>&lt;=<span style="color: #333333;"> </span>pred.key)<span style="color: #333333;"> </span>{
<span style="color: #333333;">            </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(node<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>pred)<span style="color: #333333;"> </span>{
<span style="color: #333333;">                </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>pred.next<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>curr;
<span style="color: #333333;">            </span>}
<span style="color: #333333;">            </span>node<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>node.next;
<span style="color: #333333;">            </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(node<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span><span style="color: #6F8FCC;">null</span>)<span style="color: #333333;"> </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span><span style="color: #6F8FCC;">false</span>;
<span style="color: #333333;">        </span>}
<span style="color: #333333;">    </span>}

<span style="color: #333333;">    </span><span style="color: #EF5C5F;">boolean</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">contains</span>(<span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">key</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #6F8FCC;">retry</span>:<span style="color: #333333;"> </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(<span style="color: #6F8FCC;">true</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">            </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">pred</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>head,<span style="color: #333333;"> </span><span style="color: #A197BF;">curr</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>pred.next;
<span style="color: #333333;">            </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(curr.key<span style="color: #333333;"> </span>&lt;<span style="color: #333333;"> </span><span style="color: #EF5C5F;">key</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">                </span>pred<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>curr;<span style="color: #333333;"> </span>curr<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>curr.next;
<span style="color: #333333;">                </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(curr<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span><span style="color: #6F8FCC;">null</span>)<span style="color: #333333;"> </span><span style="color: #FFA070;">continue</span><span style="color: #333333;"> </span><span style="color: #6F8FCC;">retry</span>;
<span style="color: #333333;">            </span>}
<span style="color: #333333;">            </span>pred.lock();<span style="color: #333333;"> </span>curr.lock();
<span style="color: #333333;">            </span><span style="color: #FFA070;">try</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">                </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(!validate(pred,<span style="color: #333333;"> </span>curr))<span style="color: #333333;"> </span><span style="color: #FFA070;">continue</span><span style="color: #333333;"> </span><span style="color: #6F8FCC;">retry</span>;
<span style="color: #333333;">                </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>curr.key<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>key;
<span style="color: #333333;">            </span>}<span style="color: #333333;"> </span><span style="color: #FFA070;">finally</span><span style="color: #333333;"> </span>{<span style="color: #333333;"> </span>curr.unlock();<span style="color: #333333;"> </span>pred.unlock();
<span style="color: #333333;">            </span>}
<span style="color: #333333;">        </span>}
<span style="color: #333333;">    </span>}
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">boolean</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">add</span>(<span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">key</span>,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">item</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #6F8FCC;">retry</span>:<span style="color: #333333;"> </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(<span style="color: #6F8FCC;">true</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">            </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">pred</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>head,<span style="color: #333333;"> </span><span style="color: #A197BF;">curr</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>pred.next;
<span style="color: #333333;">            </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(curr.key<span style="color: #333333;"> </span>&lt;<span style="color: #333333;"> </span><span style="color: #EF5C5F;">key</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">                </span>pred<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>curr;<span style="color: #333333;"> </span>curr<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>curr.next;
<span style="color: #333333;">                </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(curr<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span><span style="color: #6F8FCC;">null</span>)<span style="color: #333333;"> </span><span style="color: #FFA070;">continue</span><span style="color: #333333;"> </span><span style="color: #6F8FCC;">retry</span>;
<span style="color: #333333;">            </span>}
<span style="color: #333333;">            </span>pred.lock();<span style="color: #333333;"> </span>curr.lock();
<span style="color: #333333;">            </span><span style="color: #FFA070;">try</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">                </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(!validate(pred,<span style="color: #333333;"> </span>curr))<span style="color: #333333;"> </span><span style="color: #FFA070;">continue</span><span style="color: #333333;"> </span><span style="color: #6F8FCC;">retry</span>;
<span style="color: #333333;">                </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(curr.key<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>key)<span style="color: #333333;"> </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span><span style="color: #6F8FCC;">false</span>;<span style="color: #333333;"> </span><span style="color: #FFA070;">else</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">                    </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">node</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span><span style="color: #FFA070;">new</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Node</span>(key,<span style="color: #333333;"> </span>item);
<span style="color: #333333;">                    </span>node.next<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>curr;<span style="color: #333333;"> </span>pred.next<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>node;
<span style="color: #333333;">                    </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span><span style="color: #6F8FCC;">true</span>;
<span style="color: #333333;">                </span>}
<span style="color: #333333;">            </span>}<span style="color: #333333;"> </span><span style="color: #FFA070;">finally</span><span style="color: #333333;"> </span>{<span style="color: #333333;"> </span>curr.unlock();<span style="color: #333333;"> </span>pred.unlock();<span style="color: #333333;"> </span>}
<span style="color: #333333;">        </span>}
<span style="color: #333333;">    </span>}
<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">remove</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1072;&#1085;&#1072;&#1083;&#1086;&#1075;&#1080;&#1095;&#1085;&#1086;</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-7-4" class="outline-4">
<h4 id="sec-1-7-4"><span class="section-number-4">1.7.4</span> Ленивая синхронизация</h4>
<div class="outline-text-4" id="text-1-7-4">
<p>
Как строить:
</p>
<ol class="org-ol">
<li>Добавляем в <code>Node boolean</code> флажок, в котором будем помечать
удаленные элементы. Удаление в две фазы &#x2013; флажок помечен
соответствует логическому удалению, физическое следует позже.
</li>
<li>Инвариант: все непомеченные элементы всегда в списке.
</li>
<li>Результат: для валидации не надо просматривать список (только
проверить, что элементы не удалены логически и <code>pred.curr ==
       next</code>), остальное как в оптимистичном варианте.
</li>
</ol>

<p>
Поиск без ожидания:
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #FFA070;">class</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">key</span>;
<span style="color: #333333;">    </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">item</span>;
<span style="color: #333333;">    </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Lock</span><span style="color: #333333;"> </span><span style="color: #A197BF;">lock</span>;
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">boolean</span><span style="color: #333333;"> </span><span style="color: #A197BF;">marked</span>;
<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1054;&#1095;&#1077;&#1085;&#1100;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1074;&#1072;&#1078;&#1077;&#1085;</span><span style="color: #333333;"> </span><span style="color: #637579;">volatile</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1076;&#1083;&#1103;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1083;&#1080;&#1085;&#1077;&#1072;&#1088;&#1080;&#1079;&#1091;&#1077;&#1084;&#1086;&#1089;&#1090;&#1080;!</span>
<span style="color: #333333;">    </span><span style="color: #FFA070;">volatile</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">next</span>;

<span style="color: #333333;">    </span><span style="color: #EF5C5F;">void</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">lock</span>()<span style="color: #333333;"> </span>{<span style="color: #333333;"> </span>lock.lock();<span style="color: #333333;"> </span>}
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">void</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">unlock</span>()<span style="color: #333333;"> </span>{<span style="color: #333333;"> </span>lock.unlock();<span style="color: #333333;"> </span>}
}

<span style="color: #FFA070;">class</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">LinkedSet</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">boolean</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">validate</span>(<span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">prev</span>,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">next</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>!pred.marked<span style="color: #333333;"> </span>&amp;&amp;
<span style="color: #333333;">            </span>!curr.marked<span style="color: #333333;"> </span>&amp;&amp;
<span style="color: #333333;">            </span>pred.next<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>curr;
<span style="color: #333333;">    </span>}

<span style="color: #333333;">    </span><span style="color: #EF5C5F;">boolean</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">add</span>(<span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">elem</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #6F8FCC;">retry</span>:<span style="color: #333333;"> </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(<span style="color: #6F8FCC;">true</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">            </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">pred</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>head,<span style="color: #333333;"> </span><span style="color: #A197BF;">curr</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>pred.next;
<span style="color: #333333;">            </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(curr.key<span style="color: #333333;"> </span>&lt;<span style="color: #333333;"> </span><span style="color: #EF5C5F;">key</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">                </span>pred<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>curr;<span style="color: #333333;"> </span>curr<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>curr.next;
<span style="color: #333333;">                </span><span style="color: #637579;">//</span><span style="color: #333333;">                   </span><span style="color: #637579;">^^^^^^</span>
<span style="color: #333333;">                </span><span style="color: #637579;">//</span><span style="color: #333333;">            </span><span style="color: #637579;">&#1090;&#1091;&#1090;</span><span style="color: #333333;"> </span><span style="color: #637579;">curr.next</span><span style="color: #333333;"> </span><span style="color: #637579;">!=</span><span style="color: #333333;"> </span><span style="color: #637579;">null</span>
<span style="color: #333333;">            </span>}
<span style="color: #333333;">            </span>pred.lock();<span style="color: #333333;"> </span>curr.lock();
<span style="color: #333333;">            </span><span style="color: #FFA070;">try</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">                </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(!validate(pred,curr))<span style="color: #333333;"> </span><span style="color: #FFA070;">continue</span><span style="color: #333333;"> </span><span style="color: #6F8FCC;">retry</span>;
<span style="color: #333333;">                </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(curr.key<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>key)<span style="color: #333333;"> </span>{
<span style="color: #333333;">                    </span>curr.marked<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span><span style="color: #6F8FCC;">true</span>;<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1076;&#1083;&#1103;</span><span style="color: #333333;"> </span><span style="color: #637579;">validate</span>
<span style="color: #333333;">                    </span>pred.next<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>curr.next;<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1090;&#1086;&#1095;&#1082;&#1072;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1083;&#1080;&#1085;&#1077;&#1072;&#1088;&#1080;&#1079;&#1072;&#1094;&#1080;&#1080;</span>
<span style="color: #333333;">                    </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span><span style="color: #6F8FCC;">true</span>;
<span style="color: #333333;">                </span>}<span style="color: #333333;"> </span><span style="color: #FFA070;">else</span><span style="color: #333333;"> </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span><span style="color: #6F8FCC;">false</span>;
<span style="color: #333333;">            </span>}<span style="color: #333333;"> </span><span style="color: #FFA070;">finally</span><span style="color: #333333;"> </span>{<span style="color: #333333;"> </span>curr.unlock();<span style="color: #333333;"> </span>pred.unlock();<span style="color: #333333;"> </span>}
<span style="color: #333333;">        </span>}
<span style="color: #333333;">    </span>}

<span style="color: #333333;">    </span><span style="color: #EF5C5F;">void</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">delete</span><span style="color: #333333;"> </span>(<span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">elem</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #6F8FCC;">retry</span>:<span style="color: #333333;"> </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(<span style="color: #6F8FCC;">true</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">            </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">pred</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>head,<span style="color: #333333;"> </span><span style="color: #A197BF;">curr</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>pred.next;
<span style="color: #333333;">            </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(curr.key<span style="color: #333333;"> </span>&lt;<span style="color: #333333;"> </span><span style="color: #EF5C5F;">key</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">                </span>pred<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>curr;<span style="color: #333333;"> </span>curr<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>curr.next;
<span style="color: #333333;">                </span><span style="color: #637579;">//</span><span style="color: #333333;">                   </span><span style="color: #637579;">^^^^^^</span>
<span style="color: #333333;">                </span><span style="color: #637579;">//</span><span style="color: #333333;">            </span><span style="color: #637579;">&#1090;&#1091;&#1090;</span><span style="color: #333333;"> </span><span style="color: #637579;">curr.next</span><span style="color: #333333;"> </span><span style="color: #637579;">!=</span><span style="color: #333333;"> </span><span style="color: #637579;">null</span>
<span style="color: #333333;">            </span>}
<span style="color: #333333;">            </span>pred.lock();<span style="color: #333333;"> </span>curr.lock();
<span style="color: #333333;">            </span><span style="color: #FFA070;">try</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">                </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(!validate(pred,curr))<span style="color: #333333;"> </span><span style="color: #FFA070;">continue</span><span style="color: #333333;"> </span><span style="color: #6F8FCC;">retry</span>;
<span style="color: #333333;">                </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(curr.key<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>key)<span style="color: #333333;"> </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span><span style="color: #6F8FCC;">false</span>;
<span style="color: #333333;">                </span><span style="color: #FFA070;">else</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">                    </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">node</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span><span style="color: #FFA070;">new</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Node</span>(key,<span style="color: #333333;"> </span>item);
<span style="color: #333333;">                    </span>node.next<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>curr;<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1089;&#1085;&#1072;&#1095;&#1072;&#1083;&#1072;!</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1086;&#1088;&#1103;&#1076;&#1086;&#1082;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1074;&#1072;&#1078;&#1077;&#1085;</span>
<span style="color: #333333;">                    </span>pred.next<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>node;<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1090;&#1091;&#1090;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1090;&#1086;&#1095;&#1082;&#1072;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1083;&#1080;&#1085;&#1077;&#1072;&#1088;&#1080;&#1079;&#1072;&#1094;&#1080;&#1080;</span>
<span style="color: #333333;">                    </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span><span style="color: #6F8FCC;">true</span>;
<span style="color: #333333;">                </span>}
<span style="color: #333333;">            </span>}<span style="color: #333333;"> </span><span style="color: #FFA070;">finally</span><span style="color: #333333;"> </span>{<span style="color: #333333;"> </span>curr.unlock();<span style="color: #333333;"> </span>pred.unlock();<span style="color: #333333;"> </span>}
<span style="color: #333333;">        </span>}
<span style="color: #333333;">    </span>}

<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">Wait-free</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1086;&#1080;&#1089;&#1082;!</span>
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">boolean</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">contains</span>(<span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">key</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">curr</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>head;
<span style="color: #333333;">        </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(curr.key<span style="color: #333333;"> </span>&lt;<span style="color: #333333;"> </span><span style="color: #EF5C5F;">key</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">            </span>curr<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>curr.next;<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1090;&#1086;&#1095;&#1082;&#1072;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1083;&#1080;&#1085;&#1077;&#1072;&#1088;&#1080;&#1079;&#1072;&#1094;&#1080;&#1080;</span>
<span style="color: #333333;">        </span>}
<span style="color: #333333;">        </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>key<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>curr.key;
<span style="color: #333333;">    </span>}
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-7-5" class="outline-4">
<h4 id="sec-1-7-5"><span class="section-number-4">1.7.5</span> Неблокирующая синхронизация</h4>
<div class="outline-text-4" id="text-1-7-5">
<p>
Сделать синхронизацию без блокировок нетривиально:
</p>
<ul class="org-ul">
<li>Простое использование CAS не помогает &#x2013; удаление двух соседних
элементов будет конфликтовать
1, 2, 3, 4, удалим 2, 3 одновременно, но указатель 1 → 3
сохранится.
</li>
<li>Трюк такой: объединим <code>(next, marked)</code> в одну переменную, и будем ее
изменять CASом атомарно.
<ul class="org-ul">
<li>Одновременное удаление соседних двух элементов будет
конфликтовать
</li>
<li>Каждая операция модификации выполняется одним успешным CAS'ом.
</li>
<li>Это выполнение CAS'а и есть точка линеаризации
</li>
</ul>
</li>
<li>Будем пытаться удалять физически, от этого добавление и удаление
станут lock-free, а поиск вообще wait-free.
</li>
<li>В реализации будем использовать для пары
<code>java.util.concurrent.atomic.AtomicMarkableReference</code>.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8"><span class="section-number-3">1.8</span> Продолжение построений на списках, стеках</h3>
<div class="outline-text-3" id="text-1-8">
<p>
Можно строить структуры универсально, храня на нее указатель и меняя
его CAS'ом каждый раз. Так, например, работает счетчик &#x2013; в джаве
это <code>AtomicInteger</code>.
</p>

<p>
Персистентные структуры тоже несложно пишутся, достаточно заменить
CAS'ом root на новый после изменения структуры. Остальное дерево
остается прежней версии (персистентность, собсна).
</p>
</div>
<div id="outline-container-sec-1-8-1" class="outline-4">
<h4 id="sec-1-8-1"><span class="section-number-4">1.8.1</span> Стек LIFO</h4>
<div class="outline-text-4" id="text-1-8-1">
<p>
Рассмотрим частный, вырожденный случай древовидной структуры &#x2013;
стек. Он не масштабируемый. Если конкуренция очень большая, то
производительность в многосокетных системах на top будет падать.
</p>
<div class="org-src-container">

<pre class="src src-java" id="stack-implementation"><span style="color: #333333;">   </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">such</span><span style="color: #333333;"> </span><span style="color: #637579;">immutable!</span>
<span style="color: #333333;">   </span><span style="color: #FFA070;">class</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">       </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">item</span>;
<span style="color: #333333;">       </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">next</span>;
<span style="color: #333333;">   </span>}

<span style="color: #333333;">   </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">AtomicReference</span>&lt;<span style="color: #EF5C5F;">Node</span>&gt;<span style="color: #333333;"> </span><span style="color: #A197BF;">top</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span><span style="color: #FFA070;">new</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">AtomicReference</span>&lt;<span style="color: #EF5C5F;">Node</span>&gt;(<span style="color: #6F8FCC;">null</span>);

<span style="color: #333333;">   </span><span style="color: #EF5C5F;">void</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">push</span>(<span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">item</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(<span style="color: #6F8FCC;">true</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">              </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">node</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span><span style="color: #FFA070;">new</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Node</span>(item,<span style="color: #333333;"> </span>top.get());
<span style="color: #333333;">              </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(top.compareAndSet(node.next,<span style="color: #333333;"> </span>node))<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1083;&#1080;&#1085;&#1077;&#1072;&#1088;&#1080;&#1079;&#1072;&#1094;&#1080;&#1103;</span>
<span style="color: #333333;">                 </span><span style="color: #FFA070;">return</span>;
<span style="color: #333333;">        </span>}
<span style="color: #333333;">   </span>}

<span style="color: #333333;">   </span><span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">pop</span>()<span style="color: #333333;"> </span>{
<span style="color: #333333;">     </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(<span style="color: #6F8FCC;">true</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">           </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">node</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>top.get();

<span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(node<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span><span style="color: #6F8FCC;">null</span>)<span style="color: #333333;"> </span><span style="color: #FFA070;">throw</span><span style="color: #333333;"> </span><span style="color: #FFA070;">new</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">EmptyStack</span>();
<span style="color: #333333;">           </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(top.compareAndSet(node,<span style="color: #333333;"> </span>node.next))<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1083;&#1080;&#1085;&#1077;&#1072;&#1088;&#1080;&#1079;&#1072;&#1094;&#1080;&#1103;</span>
<span style="color: #333333;">              </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>node.item;
<span style="color: #333333;">     </span>}
<span style="color: #333333;">   </span>}
</pre>
</div>

<p>
С разделяемой памятью вообще все достаточно сложно, там не только
race condition'ы в большом количестве, но и куча проблем с
производительностью. Будем пока считать что стек хороший.
</p>
</div>
</div>
<div id="outline-container-sec-1-8-2" class="outline-4">
<h4 id="sec-1-8-2"><span class="section-number-4">1.8.2</span> Очереди на списках, Майкл-Скотт</h4>
<div class="outline-text-4" id="text-1-8-2">
<p>
Будем делать очередь на списках. Наивно с помощью универсальной
конструкции так себе, а популярный алгоритм &#x2013; Майкла Скотта.
</p>

<p>
Делаем список, у очереди есть указатель на голову и хвост, все
односвязно. Будем элементы добавлять и удалять достаточно
естественно.
Добавление: Создаем элемент, ссылаемся на голову, с помощью CAS'а
меняем указатель на голову в классе.
Дописать элемент в хвост сложно, потому что нужно поменять сразу две
ячейки памяти &#x2013; указатель класса на хвост, указатель предыдущего
элемента хвоста на последний.
</p>

<p>
Идея алгоритма Майкла-Скотта такая: будем брать элемент и
подписывать его в хвост, меняя ссылку предыдущего, а физически
перемещать tail (указатель из класса) потом.
Если другой поток увидит, что очередь в состоянии "есть ссылка на
tail, у которого есть следующий элемент", то он может помочь
переставить указатель класса на нужный элемент.
</p>

<div class="org-src-container">

<pre class="src src-java" id=""><span style="color: #FFA070;">class</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">item</span>;
<span style="color: #333333;">    </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">AtomicReference</span>&lt;<span style="color: #EF5C5F;">Node</span>&gt;<span style="color: #333333;"> </span><span style="color: #A197BF;">next</span>;
}

<span style="color: #EF5C5F;">AtomicReference</span>&lt;<span style="color: #EF5C5F;">Node</span>&gt;<span style="color: #333333;"> </span><span style="color: #A197BF;">head</span><span style="color: #333333;"> </span>=
<span style="color: #333333;">    </span><span style="color: #FFA070;">new</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">AtomicReference</span>&lt;<span style="color: #EF5C5F;">Node</span>&gt;(<span style="color: #FFA070;">new</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Node</span>(<span style="color: #6F8FCC;">null</span>));
<span style="color: #EF5C5F;">AtomicReference</span>&lt;<span style="color: #EF5C5F;">Node</span>&gt;<span style="color: #333333;"> </span><span style="color: #A197BF;">tail</span><span style="color: #333333;"> </span>=
<span style="color: #333333;">    </span><span style="color: #FFA070;">new</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">AtomicReference</span>&lt;<span style="color: #EF5C5F;">Node</span>&gt;(head.get());

<span style="color: #EF5C5F;">void</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">enqueue</span>(<span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">item</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">node</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span><span style="color: #FFA070;">new</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Node</span>(item);
<span style="color: #333333;"> </span>retry:<span style="color: #333333;"> </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(<span style="color: #6F8FCC;">true</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">last</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>tail.get(),
<span style="color: #333333;">            </span><span style="color: #A197BF;">next</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>last.next.get();
<span style="color: #333333;">        </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(next<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span><span style="color: #6F8FCC;">null</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">            </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(!last.next.compareAndSet(<span style="color: #6F8FCC;">null</span>,<span style="color: #333333;"> </span>node))
<span style="color: #333333;">                </span><span style="color: #FFA070;">continue</span><span style="color: #333333;"> </span><span style="color: #6F8FCC;">retry</span>;
<span style="color: #333333;">            </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1087;&#1090;&#1080;&#1084;&#1080;&#1079;&#1072;&#1094;&#1080;&#1103;</span><span style="color: #333333;"> </span><span style="color: #637579;">--</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1089;&#1072;&#1084;&#1080;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1077;&#1088;&#1077;&#1089;&#1090;&#1072;&#1074;&#1083;&#1103;&#1077;&#1084;</span><span style="color: #333333;"> </span><span style="color: #637579;">tail</span>
<span style="color: #333333;">            </span>tail.compareAndSet(last,<span style="color: #333333;"> </span>node);
<span style="color: #333333;">            </span><span style="color: #FFA070;">return</span>;
<span style="color: #333333;">        </span>}
<span style="color: #333333;">        </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1086;&#1084;&#1086;&#1075;&#1072;&#1077;&#1084;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1076;&#1088;&#1091;&#1075;&#1080;&#1084;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1087;&#1077;&#1088;&#1072;&#1094;&#1080;&#1103;&#1084;</span><span style="color: #333333;"> </span><span style="color: #637579;">enqueue</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1089;</span><span style="color: #333333;"> </span><span style="color: #637579;">tail</span>
<span style="color: #333333;">        </span>tail.compareAndSet(last,<span style="color: #333333;"> </span>next);
<span style="color: #333333;">    </span>}
}

<span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">dequeue</span>()<span style="color: #333333;"> </span>{
<span style="color: #333333;"> </span><span style="color: #6F8FCC;">retry</span>:<span style="color: #333333;"> </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(<span style="color: #6F8FCC;">true</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #EF5C5F;">Node</span><span style="color: #333333;"> </span><span style="color: #A197BF;">first</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>head.get(),
<span style="color: #333333;">            </span><span style="color: #A197BF;">last</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>tail.get(),
<span style="color: #333333;">            </span><span style="color: #A197BF;">next</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>first.next();
<span style="color: #333333;">        </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(first<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>last)<span style="color: #333333;"> </span>{
<span style="color: #333333;">            </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(next<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span><span style="color: #6F8FCC;">null</span>)<span style="color: #333333;"> </span><span style="color: #FFA070;">throw</span><span style="color: #333333;"> </span><span style="color: #FFA070;">new</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">EmptyQueue</span>();
<span style="color: #333333;">            </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1055;&#1086;&#1084;&#1086;&#1075;&#1072;&#1077;&#1084;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1087;&#1077;&#1088;&#1072;&#1094;&#1080;&#1103;&#1084;</span><span style="color: #333333;"> </span><span style="color: #637579;">enqueue</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1089;</span><span style="color: #333333;"> </span><span style="color: #637579;">tail</span>
<span style="color: #333333;">            </span>tail.compareAndSet(last,<span style="color: #333333;"> </span>next);
<span style="color: #333333;">        </span>}<span style="color: #333333;"> </span><span style="color: #FFA070;">else</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">            </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(head.compareAndSet(first,<span style="color: #333333;"> </span>next))<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1083;&#1080;&#1085;&#1077;&#1072;&#1088;&#1080;&#1079;&#1072;&#1094;&#1080;&#1103;</span>
<span style="color: #333333;">                </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>next.item;
<span style="color: #333333;">        </span>}
<span style="color: #333333;">    </span>}
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-8-3" class="outline-4">
<h4 id="sec-1-8-3"><span class="section-number-4">1.8.3</span> ABA problem</h4>
<div class="outline-text-4" id="text-1-8-3">
<p>
Есть проблема в средах без сборки мусора, называется ABA. Суть:
Будем реализовывать самый первый стек этой лекции на C, без Garbage
collector'а.
Добавим  в стек несколько элементов &#x2013; A и B.
Может быть такое, что top стека может быть: A B A.
Достанем указатель на top, сделаем успешно cas, на return нас
перебил другой поток, и что-то переаллочилось, теперь в A лежит
какая-то другая фигня.
</p>

<p>
Еще раз: в стеке 1 элемент, по адресу A (top = A).
Мы делаем ему pop, достаем A. В это время нас прерывают.
Другой поток делает pop A, push B, pop B, push C на месте A появился
другой элемент, но CAS сравнивает только указатели, и в этом случае
он не обнаружит эту проблему.
В джаве это не работает так, потому что память на A нельзя
освободить, пока на нее ссылаются.
</p>

<p>
Решить ABA проще всего с помощью реализации сборщика мусора.
Другой способ &#x2013; пользоваться версиями. Хранить в top пару из
указателя и версии. Таким образом если стек за время top.get и cas
успел поменяться, мы сравним версии и упадем. Именно поэтому мы
можем делать cas на 2х последовательных словах, это позволяет нам
менять одновременно указатель + версию.
Еще можно пользоваться Hazard Pointers &#x2013; многопоточный сборщик
мусора, который работает только для наших узлов.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9"><span class="section-number-3">1.9</span> Алгоритмы на массивах</h3>
<div class="outline-text-3" id="text-1-9">
</div><div id="outline-container-sec-1-9-1" class="outline-4">
<h4 id="sec-1-9-1"><span class="section-number-4">1.9.1</span> Стек на массиве</h4>
<div class="outline-text-4" id="text-1-9-1">
<p>
Давайте делать стек на массиве.
</p>

<p>
В однопоточном варианте стек на массиве &#x2013; очень просто.
Типа держим размер, pop/push меняет размер массива и ячейку.
Но это все равно не взлетит в многопоточном варианте совсем прям
наивно.
</p>

<p>
Вот делаем мы <code>push</code>. Сначала увеличим top cas'ом, а потом проставим
элемент. Push будет работать, но pop в такой реализации упадет &#x2013;
если мы уже увеличили top, но не положили элемент, то достанет
какой-то мусор.
</p>

<p>
Аналогично если сначала проставляем элемент, а потом увеличиваем
<code>top</code>, то там будет что-то старое.
</p>

<p>
С очередями проблемы те же.
</p>

<p>
Будем писать дек, пытаясь реализовать obstruction-free свойство.
Дек будет циклическим.  Храним в элементе пару &#x2013; значение и
версия. Там где дек пустой, будем хранить <code>(left_null, version)</code>,
справа <code>(right_null, version)</code>.
</p>

<p>
Для корректности алгоритма не будем полагаться на указатели <code>left</code> и
<code>right</code> в классе дека &#x2013; они будут типа для производительности, а
индексироваться будем за \(O(n)\).
</p>

<p>
На практике этим никто не пользуется, потому что все равно
медленнее, чем на ссылочном листе.
</p>

<div class="org-src-container">

<pre class="src src-java" id=""><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">rightOracle</span>()<span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">k</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>right;<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1076;&#1083;&#1103;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1087;&#1090;&#1080;&#1084;&#1080;&#1079;&#1072;&#1094;&#1080;&#1080;</span>
<span style="color: #333333;">    </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(a[k]<span style="color: #333333;"> </span>!=<span style="color: #333333;"> </span>RN)<span style="color: #333333;"> </span>k++;
<span style="color: #333333;">    </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(a[k-1]<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>RN)<span style="color: #333333;"> </span>k--;
<span style="color: #333333;">    </span>right<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>k;<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1079;&#1072;&#1087;&#1086;&#1084;&#1085;&#1080;&#1083;&#1080;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1076;&#1083;&#1103;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1087;&#1090;&#1080;&#1084;&#1080;&#1079;&#1072;&#1094;&#1080;&#1080;</span>
<span style="color: #333333;">    </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>k;
}

<span style="color: #EF5C5F;">void</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">rightPush</span>(<span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">item</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;"> </span><span style="color: #6F8FCC;">retry</span>:<span style="color: #333333;"> </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(<span style="color: #6F8FCC;">true</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">k</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>rightOracle();
<span style="color: #333333;">        </span>{<span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">item</span>,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">ver</span>}<span style="color: #333333;"> </span>prev<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>a[k-1],<span style="color: #333333;"> </span>cur<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>a[k];
<span style="color: #333333;">        </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(prev.item<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>RN<span style="color: #333333;"> </span>||<span style="color: #333333;"> </span>cur.item<span style="color: #333333;"> </span>!=<span style="color: #333333;"> </span>RN)<span style="color: #333333;"> </span><span style="color: #FFA070;">continue</span>;
<span style="color: #333333;">        </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(k<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>MAX-1)<span style="color: #333333;"> </span><span style="color: #FFA070;">throw</span><span style="color: #333333;"> </span><span style="color: #FFA070;">new</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">FullDeque</span>();
<span style="color: #333333;">        </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(CAS(a[k-1],<span style="color: #333333;"> </span>prev,<span style="color: #333333;"> </span>{prev.item,<span style="color: #333333;"> </span>prev.ver+1}<span style="color: #333333;"> </span>&amp;&amp;
<span style="color: #333333;">                </span>CAS(a[k],<span style="color: #333333;"> </span>cur,<span style="color: #333333;"> </span>{item,<span style="color: #333333;"> </span>cur.ver+1})))<span style="color: #333333;"> </span><span style="color: #FFA070;">return</span>;
<span style="color: #333333;">    </span>}
}

<span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">rightPop</span>()<span style="color: #333333;"> </span>{
<span style="color: #333333;"> </span><span style="color: #6F8FCC;">retry</span>:<span style="color: #333333;"> </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(<span style="color: #6F8FCC;">true</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">k</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>oracleRight();
<span style="color: #333333;">        </span>{<span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">item</span>,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">ver</span>}<span style="color: #333333;"> </span>cur<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>a[k-1],<span style="color: #333333;"> </span>next<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>a[k];
<span style="color: #333333;">        </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(cur.itim<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>RN<span style="color: #333333;"> </span>||<span style="color: #333333;"> </span>next.item<span style="color: #333333;"> </span>!=<span style="color: #333333;"> </span>RN)<span style="color: #333333;"> </span><span style="color: #FFA070;">continue</span>;
<span style="color: #333333;">        </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(cur.item<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>LN)<span style="color: #333333;"> </span><span style="color: #FFA070;">throw</span><span style="color: #333333;"> </span><span style="color: #FFA070;">new</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">EmptyDeque</span>();
<span style="color: #333333;">        </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(CAS(a[k],<span style="color: #333333;"> </span>next,<span style="color: #333333;"> </span>{RN,<span style="color: #333333;"> </span>next.ver+1})<span style="color: #333333;"> </span>&amp;&amp;
<span style="color: #333333;">            </span>CAS(a[k-1],<span style="color: #333333;"> </span>cur,<span style="color: #333333;"> </span>{RN,<span style="color: #333333;"> </span>cur.ver<span style="color: #333333;"> </span>+<span style="color: #333333;"> </span>1}))
<span style="color: #333333;">            </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>cur.item;
<span style="color: #333333;">    </span>}
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-9-2" class="outline-4">
<h4 id="sec-1-9-2"><span class="section-number-4">1.9.2</span> Хэш-таблицы на массиве</h4>
<div class="outline-text-4" id="text-1-9-2">
<p>
Бывают с прямой адресацией (по хэшу находим ведро, и все элементы с
таким хэшом попадают в это ведро &#x2013; там дальше список или дерево).
На практике с прямой адресацией все медленно, потому что там опять
массивы или списки.
Бывают с открытой, это самый лучший вариант.
Но со списками намного проще.
</p>

<p>
Будем пользоваться алгоритмом Split-Ordered lists.
Засунем все элементы в одно большое связанео множество. Упорядочим
их по хэшу. Для ускорения заведем слева хэш-таблицу, адресующую те
элементы листа с заданным хэшом. Эта дополнительная таблица делается
только для ускорения.
Когда будем хотеть расширить таблицу, создадим вторую, скопируем ее
черезстрочно, будем по мере обращений к хэшу ее обновлять (вторую).
</p>


<p>
Открытая адресация.
Делаем на массиве, будем считать ведро по хэшкоду, если занято, то
дальше.
Добавлять из нескольких потоков легко &#x2013; просто делаем cas. Удалять
из такой таблицы можно прописывая некоторое особенное
значение T. Нельзя прудмать алгоритм, который бы многопоточно
закрывал дырки в этих списках.
Ну, допустим мы забиваем элементы T, но как перевыделять память со
временем &#x2013; для освобождения элементов T или расширения таблицы.
</p>

<p>
Сделаем так, что таблица хранит указатель на "реальную" внутреннюю
таблицу. Когда копируем, создаем новую таблицу, а указатель поставим
в конце. Операция изменения ищет в новой таблице, если нету, то ищет
в старой, если находит &#x2013; копирует в новую.
Таким образом мы перенесем все элементы в новую таблицу.
Как переносить, собственно?
</p>

<p>
Если собираемся переносить, то пометим битиком значение. После этого
мы занимаем слот в новой таблице, после этого копируем значение в
новой таблице. Затем в старой пометим, что мы уже скопировали.
</p>
<div class="org-src-container">

<pre class="src src-text">(0, 0)
   &#8595;
{Claim key}
   &#8595;
(K, 0)
   &#8595;
{Set value}
   &#8595;
(K, V)            &#8594; Start copy &#8594; (K, V')
   &#8597;                               &#8593;
{insert/delete}                  Moved
   &#8597;                               &#8593;
(K, T)            &#8594; Moved      &#8594; (K, T')
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-10" class="outline-3">
<h3 id="sec-1-10"><span class="section-number-3">1.10</span> CASN</h3>
<div class="outline-text-3" id="text-1-10">
<p>
Этот алгоритм с переносом таблиц есть частный случай.
Хотим чтобы работало корректно (линеаризуемо) и:
</p>
<ol class="org-ol">
<li>Lock-free.
</li>
<li>Disjoint-Access Parallel (непересекающиеся доступы параллельны).
</li>
</ol>

<div class="org-src-container">

<pre class="src src-java" id="CASN"><span style="color: #EF5C5F;">boolean</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">CASN</span>(<span style="color: #EF5C5F;">CASEntry</span>...<span style="color: #333333;"> </span><span style="color: #A197BF;">entries</span>)<span style="color: #333333;"> </span>atomic<span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #FFA070;">for</span><span style="color: #333333;"> </span>(<span style="color: #EF5C5F;">CASEntry</span><span style="color: #333333;"> </span><span style="color: #A197BF;">entry</span>:<span style="color: #333333;"> </span>entries)
<span style="color: #333333;">        </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(entry.a.value<span style="color: #333333;"> </span>!=<span style="color: #333333;"> </span>entry.expect)
<span style="color: #333333;">            </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span><span style="color: #6F8FCC;">false</span>;
<span style="color: #333333;">    </span><span style="color: #FFA070;">for</span><span style="color: #333333;"> </span>(<span style="color: #EF5C5F;">CASEntry</span><span style="color: #333333;"> </span><span style="color: #A197BF;">entry</span>:<span style="color: #333333;"> </span>entries)
<span style="color: #333333;">        </span>entry.a.value<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>entry.update;
<span style="color: #333333;">    </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span><span style="color: #6F8FCC;">true</span>;
}
</pre>
</div>

<p>
Если мы сделаем CASN, то сделаем стек на массиве &#x2013; будем
одновременно делать CAS 2 раза.
</p>

<div class="org-src-container">

<pre class="src src-java" id="CASN"><span style="color: #FFA070;">import</span><span style="color: #333333;"> </span><span style="color: #6F8FCC;">java</span>.<span style="color: #6F8FCC;">util</span>.<span style="color: #6F8FCC;">concurrent</span>.<span style="color: #6F8FCC;">atomic</span>.<span style="color: #EF5C5F;">AtomicReferenceFieldUpdater</span>;

<span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #FFA070;">class</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">CASEntry</span>&lt;<span style="color: #EF5C5F;">T</span>&gt;<span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">DataReference</span>&lt;<span style="color: #EF5C5F;">T</span>&gt;<span style="color: #333333;"> </span><span style="color: #A197BF;">a</span>;<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1095;&#1090;&#1086;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1086;&#1084;&#1077;&#1085;&#1103;&#1090;&#1100;</span>
<span style="color: #333333;">    </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">expect</span>;<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1078;&#1080;&#1076;&#1072;&#1077;&#1084;&#1086;&#1077;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077;</span>
<span style="color: #333333;">    </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">update</span>;<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1085;&#1072;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1095;&#1090;&#1086;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1079;&#1072;&#1084;&#1077;&#1085;&#1080;&#1090;&#1100;</span>
<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1048;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1090;&#1091;&#1090;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1088;&#1086;&#1089;&#1090;&#1086;&#1081;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1082;&#1086;&#1085;&#1089;&#1090;&#1088;&#1091;&#1082;&#1090;&#1086;&#1088;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1076;&#1083;&#1103;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1074;&#1089;&#1077;&#1093;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1090;&#1088;&#1077;&#1093;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1086;&#1083;&#1077;&#1081;</span>
}

<span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">RDCSS</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1089;&#1083;&#1086;&#1078;&#1085;&#1072;,</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1090;&#1086;&#1083;&#1100;&#1082;&#1086;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1077;&#1089;&#1083;&#1080;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1103;&#1095;&#1077;&#1081;&#1082;&#1072;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1084;&#1086;&#1078;&#1077;&#1090;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1089;&#1090;&#1088;&#1072;&#1076;&#1072;&#1090;&#1100;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1090;</span><span style="color: #333333;"> </span><span style="color: #637579;">ABA.</span>
<span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1045;&#1089;&#1083;&#1080;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1085;&#1077;&#1090;,</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1090;&#1086;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1088;&#1086;&#1097;&#1077;.</span>
<span style="color: #FFA070;">class</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">RDCSSDescriptor</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #FFA070;">private</span><span style="color: #333333;"> </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">DataReference</span><span style="color: #333333;"> </span><span style="color: #A197BF;">a1</span>;
<span style="color: #333333;">    </span><span style="color: #FFA070;">private</span><span style="color: #333333;"> </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Object</span><span style="color: #333333;"> </span><span style="color: #A197BF;">expect1</span>;
<span style="color: #333333;">    </span><span style="color: #FFA070;">private</span><span style="color: #333333;"> </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">DataReference</span><span style="color: #333333;"> </span><span style="color: #A197BF;">a2</span>;
<span style="color: #333333;">    </span><span style="color: #FFA070;">private</span><span style="color: #333333;"> </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Object</span><span style="color: #333333;"> </span><span style="color: #A197BF;">expect2</span>;

<span style="color: #333333;">    </span><span style="color: #FFA070;">private</span><span style="color: #333333;"> </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Object</span><span style="color: #333333;"> </span><span style="color: #A197BF;">update2</span>;
<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1080;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1082;&#1086;&#1085;&#1089;&#1090;&#1088;&#1091;&#1082;&#1090;&#1086;&#1088;</span>

<span style="color: #333333;">    </span><span style="color: #EF5C5F;">Object</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">invoke</span>()<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #EF5C5F;">Object</span><span style="color: #333333;"> </span><span style="color: #A197BF;">r</span>;
<span style="color: #333333;">        </span><span style="color: #FFA070;">do</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">            </span>r<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>a2.getAndCAS(expect2,<span style="color: #333333;"> </span><span style="color: #FFA070;">this</span>);
<span style="color: #333333;">            </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(r<span style="color: #333333;"> </span><span style="color: #FFA070;">instanceof</span><span style="color: #333333;"> </span>RDCSSDescriptor)
<span style="color: #333333;">                </span>((<span style="color: #EF5C5F;">RDCSSDescriptor</span>)r).complete();
<span style="color: #333333;">        </span>}<span style="color: #333333;"> </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(r<span style="color: #333333;"> </span><span style="color: #FFA070;">instanceof</span><span style="color: #333333;"> </span>RDCSSDescriptor);
<span style="color: #333333;">        </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(r<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>expect2)<span style="color: #333333;"> </span>complete();
<span style="color: #333333;">        </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>r;
<span style="color: #333333;">    </span>}

<span style="color: #333333;">    </span><span style="color: #EF5C5F;">void</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">complete</span>()<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(a1.value<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>expect1)<span style="color: #333333;"> </span><span style="color: #6F8FCC;">a2</span>.CAS(<span style="color: #FFA070;">this</span>,<span style="color: #333333;"> </span>update2);
<span style="color: #333333;">        </span><span style="color: #FFA070;">else</span><span style="color: #333333;"> </span><span style="color: #6F8FCC;">a2</span>.CAS(<span style="color: #FFA070;">this</span>.expect2);
<span style="color: #333333;">    </span>}
}

<span style="color: #FFA070;">enum</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Status</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #A197BF;">UNDECINED</span>,<span style="color: #333333;"> </span><span style="color: #A197BF;">SUCCEEDED</span>,<span style="color: #333333;"> </span><span style="color: #A197BF;">FAILED</span>
}

<span style="color: #FFA070;">class</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">CASNDescriptor</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #FFA070;">private</span><span style="color: #333333;"> </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">DataReference</span><span style="color: #333333;"> </span><span style="color: #A197BF;">status</span><span style="color: #333333;"> </span>=
<span style="color: #333333;">        </span><span style="color: #FFA070;">new</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">DataReference</span>(<span style="color: #6F8FCC;">Status</span>.UNDECINED);
<span style="color: #333333;">    </span><span style="color: #FFA070;">private</span><span style="color: #333333;"> </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">CASEntry</span>[]<span style="color: #333333;"> </span><span style="color: #A197BF;">entries</span>;

<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1085;&#1072;&#1076;&#1086;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1075;&#1072;&#1088;&#1072;&#1085;&#1090;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1076;&#1080;&#1085;&#1072;&#1082;&#1086;&#1074;&#1099;&#1081;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1086;&#1088;&#1103;&#1076;&#1086;&#1082;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1073;&#1088;&#1072;&#1073;&#1086;&#1090;&#1082;&#1080;</span>
<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">DataReference</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1082;&#1072;&#1078;&#1076;&#1099;&#1084;</span><span style="color: #333333;"> </span><span style="color: #637579;">CASN,</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1080;&#1093;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1085;&#1072;&#1076;&#1086;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1082;&#1072;&#1082;-&#1090;&#1086;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1091;&#1087;&#1086;&#1088;&#1103;&#1076;&#1086;&#1095;&#1080;&#1090;&#1100;</span>
<span style="color: #333333;">    </span><span style="color: #8AAFFA;">CASNDescriptor</span>(<span style="color: #EF5C5F;">CASEntry</span>[]<span style="color: #333333;"> </span><span style="color: #A197BF;">entries</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #FFA070;">this</span>.entries<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>entries;
<span style="color: #333333;">        </span>Arrays.sort(<span style="color: #FFA070;">this</span>.entries);
<span style="color: #333333;">    </span>}

<span style="color: #333333;">    </span><span style="color: #EF5C5F;">boolean</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">complete</span>()<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(status.value<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span><span style="color: #6F8FCC;">Status</span>.UNDECINED)<span style="color: #333333;"> </span>{
<span style="color: #333333;">            </span><span style="color: #EF5C5F;">Status</span><span style="color: #333333;"> </span><span style="color: #A197BF;">newStatus</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span><span style="color: #6F8FCC;">Status</span>.SUCCEEDED;
<span style="color: #333333;">            </span><span style="color: #FFA070;">for</span><span style="color: #333333;"> </span>(<span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">i</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>0;<span style="color: #333333;"> </span>i<span style="color: #333333;"> </span>&lt;<span style="color: #333333;"> </span>entries.<span style="color: #EF5C5F;">length</span>;)<span style="color: #333333;"> </span>{
<span style="color: #333333;">                </span><span style="color: #EF5C5F;">CASEntry</span><span style="color: #333333;"> </span><span style="color: #A197BF;">entry</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>entries[i];
<span style="color: #333333;">                </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">AQUIRE</span><span style="color: #333333;"> </span><span style="color: #637579;">ENTRY</span>
<span style="color: #333333;">                </span><span style="color: #EF5C5F;">Object</span><span style="color: #333333;"> </span><span style="color: #A197BF;">val</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span><span style="color: #FFA070;">new</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">RDCSSDescriptor</span>(<span style="color: #FFA070;">this</span>.status,
<span style="color: #333333;">                                                 </span><span style="color: #6F8FCC;">Status</span>.UNDECIDED,
<span style="color: #333333;">                                                 </span>entry.a,
<span style="color: #333333;">                                                 </span>entry.expect,
<span style="color: #333333;">                                                 </span><span style="color: #FFA070;">this</span>).invoke();
<span style="color: #333333;">                </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">AQUIRE</span><span style="color: #333333;"> </span><span style="color: #637579;">ENTRY</span><span style="color: #333333;"> </span><span style="color: #637579;">END</span>

<span style="color: #333333;">                </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(val<span style="color: #333333;"> </span><span style="color: #FFA070;">instanceof</span><span style="color: #333333;"> </span>CASNDescriptor)<span style="color: #333333;"> </span>{
<span style="color: #333333;">                    </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(val<span style="color: #333333;"> </span>!=<span style="color: #333333;"> </span><span style="color: #FFA070;">this</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">                        </span>((<span style="color: #EF5C5F;">CASNDescriptor</span>)val).complete();
<span style="color: #333333;">                        </span><span style="color: #FFA070;">continue</span>;<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">retry</span><span style="color: #333333;"> </span><span style="color: #637579;">this</span><span style="color: #333333;"> </span><span style="color: #637579;">entry</span>
<span style="color: #333333;">                    </span>}
<span style="color: #333333;">                </span>}<span style="color: #333333;"> </span><span style="color: #FFA070;">else</span><span style="color: #333333;"> </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(val<span style="color: #333333;"> </span>!=<span style="color: #333333;"> </span>entry.expect)<span style="color: #333333;"> </span>{
<span style="color: #333333;">                    </span>newStatus<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span><span style="color: #6F8FCC;">Status</span>.FAILED;
<span style="color: #333333;">                    </span><span style="color: #FFA070;">break</span>;
<span style="color: #333333;">                </span>}
<span style="color: #333333;">                </span>i++;<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">go</span><span style="color: #333333;"> </span><span style="color: #637579;">to</span><span style="color: #333333;"> </span><span style="color: #637579;">next</span><span style="color: #333333;"> </span><span style="color: #637579;">entry</span>
<span style="color: #333333;">            </span>}
<span style="color: #333333;">            </span><span style="color: #FFA070;">this</span>.<span style="color: #6F8FCC;">status</span>.CAS(<span style="color: #6F8FCC;">Status</span>.UNDECIDED,<span style="color: #333333;"> </span>newStatus);
<span style="color: #333333;">        </span>}
<span style="color: #333333;">        </span><span style="color: #EF5C5F;">boolean</span><span style="color: #333333;"> </span><span style="color: #A197BF;">succeeded</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>status.value<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span><span style="color: #6F8FCC;">Status</span>.SUCCEEDED;
<span style="color: #333333;">        </span><span style="color: #FFA070;">for</span><span style="color: #333333;"> </span>(<span style="color: #EF5C5F;">CASEntry</span><span style="color: #333333;"> </span><span style="color: #A197BF;">entry</span><span style="color: #333333;"> </span>:<span style="color: #333333;"> </span>entries)<span style="color: #333333;"> </span>{
<span style="color: #333333;">            </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">RELEASE</span>
<span style="color: #333333;">            </span><span style="color: #6F8FCC;">entry</span>.<span style="color: #6F8FCC;">a</span>.CAS(<span style="color: #FFA070;">this</span>,<span style="color: #333333;"> </span>succeeded<span style="color: #333333;"> </span>?<span style="color: #333333;"> </span>entry.update<span style="color: #333333;"> </span>:<span style="color: #333333;"> </span>entry.expect);
<span style="color: #333333;">        </span>}
<span style="color: #333333;">        </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>succeeded;
<span style="color: #333333;">    </span>}
}

<span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #FFA070;">class</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">DataReference</span>&lt;<span style="color: #EF5C5F;">T</span>&gt;<span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1093;&#1088;&#1072;&#1085;&#1080;&#1084;&#1086;&#1077;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077;</span>
<span style="color: #333333;">    </span><span style="color: #FFA070;">volatile</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Object</span><span style="color: #333333;"> </span><span style="color: #A197BF;">value</span>;

<span style="color: #333333;">    </span><span style="color: #FFA070;">private</span><span style="color: #333333;"> </span><span style="color: #FFA070;">static</span><span style="color: #333333;"> </span><span style="color: #FFA070;">final</span>
<span style="color: #333333;">      </span><span style="color: #EF5C5F;">AtomicReferenceFieldUpdater</span>&lt;<span style="color: #EF5C5F;">DataReference</span>,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">Object</span>&gt;
<span style="color: #333333;">        </span><span style="color: #A197BF;">VALUE_UPDATER</span><span style="color: #333333;"> </span>=
<span style="color: #333333;">          </span>AtomicReferenceFieldUpdater.newUpdater(
<span style="color: #333333;">            </span>DataReference.<span style="color: #FFA070;">class</span>,<span style="color: #333333;"> </span>Object.<span style="color: #FFA070;">class</span>,<span style="color: #333333;"> </span><span style="color: #868B44;">"value"</span>);

<span style="color: #333333;">    </span><span style="color: #EF5C5F;">boolean</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">CAS</span>(<span style="color: #EF5C5F;">Object</span><span style="color: #333333;"> </span><span style="color: #A197BF;">expect</span>,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">Object</span><span style="color: #333333;"> </span><span style="color: #A197BF;">update</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>VALUE_UPDATER.compareAndSet(<span style="color: #FFA070;">this</span>,<span style="color: #333333;"> </span>expect,<span style="color: #333333;"> </span>update);
<span style="color: #333333;">    </span>}

<span style="color: #333333;">    </span><span style="color: #EF5C5F;">Object</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">getAndCAS</span>(<span style="color: #EF5C5F;">Object</span><span style="color: #333333;"> </span><span style="color: #A197BF;">expect</span>,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">Object</span><span style="color: #333333;"> </span><span style="color: #A197BF;">update</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #FFA070;">do</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">            </span><span style="color: #EF5C5F;">Object</span><span style="color: #333333;"> </span><span style="color: #A197BF;">curval</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>value;
<span style="color: #333333;">            </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(curval<span style="color: #333333;"> </span>!=<span style="color: #333333;"> </span>expect)<span style="color: #333333;"> </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>curval;
<span style="color: #333333;">        </span>}<span style="color: #333333;"> </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(!CAS(expect,<span style="color: #333333;"> </span>update));
<span style="color: #333333;">        </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>expect;
<span style="color: #333333;">    </span>}

<span style="color: #333333;">    </span><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">get</span>()<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(<span style="color: #6F8FCC;">true</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">            </span><span style="color: #EF5C5F;">Object</span><span style="color: #333333;"> </span><span style="color: #A197BF;">curval</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>value;
<span style="color: #333333;">            </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(curval<span style="color: #333333;"> </span><span style="color: #FFA070;">instanceof</span><span style="color: #333333;"> </span>RDCSSDescriptor)<span style="color: #333333;"> </span>{
<span style="color: #333333;">                </span>((<span style="color: #EF5C5F;">RDCSSDescriptor</span>)curval).complete();
<span style="color: #333333;">                </span><span style="color: #FFA070;">continue</span>;
<span style="color: #333333;">            </span>}
<span style="color: #333333;">            </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(curval<span style="color: #333333;"> </span><span style="color: #FFA070;">instanceof</span><span style="color: #333333;"> </span>CASNDescriptor)<span style="color: #333333;"> </span>{
<span style="color: #333333;">                </span>((<span style="color: #EF5C5F;">CASNDescriptor</span>)curval).complete();
<span style="color: #333333;">                </span><span style="color: #FFA070;">continue</span>;<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">retry</span>
<span style="color: #333333;">            </span>}
<span style="color: #333333;">            </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>(<span style="color: #EF5C5F;">T</span>)curval;
<span style="color: #333333;">        </span>}
<span style="color: #333333;">    </span>}

<span style="color: #333333;">    </span><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">get</span>();
<span style="color: #333333;">    </span><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #FFA070;">static</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">boolean</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">CASN</span>(<span style="color: #EF5C5F;">CASEntry</span>...<span style="color: #333333;"> </span><span style="color: #A197BF;">entries</span>);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-11" class="outline-3">
<h3 id="sec-1-11"><span class="section-number-3">1.11</span> Сложные блокировки</h3>
<div class="outline-text-3" id="text-1-11">
<p>
Проведем анализ <b>конфликтов</b> (<i>data race</i>) &#x2013; два
несинхронизированных доступа к одной ячейке данных, один из которых
запись.
</p>

<p>
<b>Матрица конфликтов</b> (для регистра) &#x2013; какие методы конфликтуют:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">&#xa0;</th>
<th scope="col" class="left">R</th>
<th scope="col" class="left">W</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">R</td>
<td class="left">&#xa0;</td>
<td class="left">×</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">W</td>
<td class="left">×</td>
<td class="left">×</td>
</tr>
</tbody>
</table>

<p>
Подход этой матрицы позволяет чисто автоматизированно составить
матрицу для сложной структуры с большим количеством методов.
</p>

<p>
Можно тривиально убрать конфликты с помощью грубой блокировки на
каждом конфликтующем методе.
С другой стороны, жиненная ситуация &#x2013; после грубой блокировки
некоторые методы могут работать одновременно (к примеру только
читающие методы).
</p>

<p>
Эту проблему решают read-write locks. Можем создать класс, который
умеет лочиться по <code>read</code> или по <code>write</code>. Такой класс будет принимать
сколько угодно локов по <code>read</code>, но остальные не будут совместимы.
</p>

<p>
Другое решение &#x2013; делать структуру данных, используя тонкую
блокировку. Например, с помощью CASN.
</p>

<p>
Как сделать линеаризуемый многопоточный объект?
</p>
<ol class="org-ol">
<li>Блокировки (aka synchronized): грубая, тонкая, &#x2026;, read-write.
</li>
<li>Без блокировки
<ol class="org-ol">
<li>Универсальная конструкция (Copy-on-write + CAS, частичное
копирование + CAS).
</li>
<li>CASN.
</li>
<li>Специфичные для структуры алгоритмы.
</li>
</ol>
</li>
</ol>

<p>
Проблемы блокировки:
</p>
<ol class="org-ol">
<li>В системе нет прогресса, пока объект заблокирован.
</li>
<li>Требуются дополнительные переключения контекста чтобы дать
закончить работу блокирующему потоку. Это может сильно жрать
CPU.
</li>
<li>Минимальный параллелизм работы, причем параллелизм обратно
пропорционален количеству блокировок.
</li>
<li>Deadlocks.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-12" class="outline-3">
<h3 id="sec-1-12"><span class="section-number-3">1.12</span> STM</h3>
<div class="outline-text-3" id="text-1-12">
<p>
Как делать сложные вещи и не думать? STM!  Типа навешиваем какие-то
вещи на кусок кода, и он выполняется атомарно. Такое есть, например,
в Clojure. И в хаскеле тоже есть! Проблема &#x2013; оно работает медленно
и поэтому не подходит для плюсов/джавы.
</p>

<div class="org-src-container">

<pre class="src src-java" id="STM"><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #FFA070;">class</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Employees</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">Set</span><span style="color: #333333;"> </span><span style="color: #A197BF;">working</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span><span style="color: #FFA070;">new</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">ConcurrentSet</span>();
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">Set</span><span style="color: #333333;"> </span><span style="color: #A197BF;">vacating</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span><span style="color: #FFA070;">new</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">ConcurrentSet</span>();

<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1089;&#1077;&#1074;&#1076;&#1086;&#1082;&#1086;&#1076;</span>
<span style="color: #333333;">    </span><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">boolean</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">contains</span>(<span style="color: #EF5C5F;">Employee</span><span style="color: #333333;"> </span><span style="color: #A197BF;">e</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span>atomic<span style="color: #333333;"> </span>{
<span style="color: #333333;">            </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>working.contains(e)<span style="color: #333333;"> </span>||
<span style="color: #333333;">                </span>vaccating.contains(e);
<span style="color: #333333;">        </span>}
<span style="color: #333333;">    </span>}

<span style="color: #333333;">    </span><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">void</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">startVacation</span>(<span style="color: #EF5C5F;">Employee</span><span style="color: #333333;"> </span><span style="color: #A197BF;">e</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span>atomic<span style="color: #333333;"> </span>{
<span style="color: #333333;">            </span>working.remove(e);
<span style="color: #333333;">            </span>vacating.add(e);
<span style="color: #333333;">        </span>}
<span style="color: #333333;">    </span>}
}
</pre>
</div>

<p>
Будем писать класс транзакций и класс переменной для транзакции.
</p>
</div>
<div id="outline-container-sec-1-12-1" class="outline-4">
<h4 id="sec-1-12-1"><span class="section-number-4">1.12.1</span> Транзакции с блокировкой:</h4>
<div class="outline-text-4" id="text-1-12-1">
<ul class="org-ul">
<li>Можно двухфазовой блокировкой. Все конфликтующие блокировки
защищаются локами, в начале транзакции локи накапливаются, в
конце отпускаются.
</li>
<li>Тогда любое исполнение такой системы будет линеаризуемо
</li>
</ul>
<div class="org-src-container">

<pre class="src src-java" id=""><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #FFA070;">class</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Transaction</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #FFA070;">private</span><span style="color: #333333;"> </span><span style="color: #FFA070;">static</span><span style="color: #333333;"> </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">ThreadLocal</span>&lt;<span style="color: #EF5C5F;">Transaction</span>&gt;<span style="color: #333333;"> </span><span style="color: #A197BF;">CURRENT</span><span style="color: #333333;"> </span>=
<span style="color: #333333;">        </span><span style="color: #FFA070;">new</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">ThreadLocal</span>&lt;<span style="color: #EF5C5F;">Transaction</span>&gt;();

<span style="color: #333333;">    </span><span style="color: #FFA070;">private</span><span style="color: #333333;"> </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">List</span>&lt;<span style="color: #EF5C5F;">Lock</span>&gt;<span style="color: #333333;"> </span><span style="color: #A197BF;">locks</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span><span style="color: #FFA070;">new</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">ArrayList</span>&lt;<span style="color: #EF5C5F;">Lock</span>&gt;();

<span style="color: #333333;">    </span><span style="color: #FFA070;">private</span><span style="color: #333333;"> </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Set</span>&lt;<span style="color: #EF5C5F;">TVar</span>&lt;?&gt;&gt;<span style="color: #333333;"> </span><span style="color: #A197BF;">writes</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span><span style="color: #FFA070;">new</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">HashSet</span>&lt;<span style="color: #EF5C5F;">TVar</span>&lt;?&gt;&gt;();

<span style="color: #333333;">    </span><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">void</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">addWrite</span>(<span style="color: #EF5C5F;">TVar</span>&lt;?&gt;<span style="color: #333333;"> </span><span style="color: #A197BF;">var</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span>writes.add(var);
<span style="color: #333333;">    </span>}

<span style="color: #333333;">    </span><span style="color: #EF5C5F;">void</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">addLock</span>(<span style="color: #EF5C5F;">Lock</span><span style="color: #333333;"> </span><span style="color: #A197BF;">lock</span>)<span style="color: #333333;"> </span>{<span style="color: #333333;"> </span>locks.add(lock);<span style="color: #333333;"> </span>}

<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">commit</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1089;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1073;&#1083;&#1086;&#1082;&#1080;&#1088;&#1086;&#1074;&#1082;&#1086;&#1081;</span>
<span style="color: #333333;">    </span><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">boolean</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">commit</span>()<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #FFA070;">for</span><span style="color: #333333;"> </span>(<span style="color: #EF5C5F;">Lock</span><span style="color: #333333;"> </span><span style="color: #A197BF;">lock</span><span style="color: #333333;"> </span>:<span style="color: #333333;"> </span>locks)<span style="color: #333333;"> </span>lock.unlock();
<span style="color: #333333;">        </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span><span style="color: #6F8FCC;">true</span>;
<span style="color: #333333;">    </span>}

<span style="color: #333333;">    </span><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">void</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">rollback</span>()<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #FFA070;">for</span><span style="color: #333333;"> </span>(<span style="color: #EF5C5F;">TVar</span>&lt;?&gt;<span style="color: #333333;"> </span><span style="color: #A197BF;">var</span><span style="color: #333333;"> </span>:<span style="color: #333333;"> </span>writes)<span style="color: #333333;"> </span>var.rollback();
<span style="color: #333333;">        </span><span style="color: #FFA070;">for</span><span style="color: #333333;"> </span>(<span style="color: #EF5C5F;">Lock</span><span style="color: #333333;"> </span><span style="color: #A197BF;">lock</span><span style="color: #333333;"> </span>:<span style="color: #333333;"> </span>locks)<span style="color: #333333;"> </span>lock.unlock();
<span style="color: #333333;">    </span>}

<span style="color: #333333;">    </span><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #FFA070;">static</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Transaction</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">beginTransaction</span>()<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #EF5C5F;">Transaction</span><span style="color: #333333;"> </span><span style="color: #A197BF;">t</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span><span style="color: #FFA070;">new</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Transaction</span>();
<span style="color: #333333;">        </span>CURRENT.set(t);
<span style="color: #333333;">        </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>t;
<span style="color: #333333;">    </span>}

<span style="color: #333333;">    </span><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #FFA070;">static</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Transaction</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">currentTransaction</span>()<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>CURRENT.get();
<span style="color: #333333;">    </span>}

<span style="color: #333333;">    </span><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #FFA070;">static</span><span style="color: #333333;"> </span>&lt;<span style="color: #EF5C5F;">R</span>&gt;<span style="color: #333333;"> </span><span style="color: #EF5C5F;">R</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">atomic</span>(<span style="color: #EF5C5F;">AtomicBlock</span>&lt;<span style="color: #EF5C5F;">R</span>&gt;<span style="color: #333333;"> </span><span style="color: #A197BF;">call</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #FFA070;">for</span><span style="color: #333333;"> </span>(;;)<span style="color: #333333;"> </span>{
<span style="color: #333333;">            </span><span style="color: #EF5C5F;">Transacion</span><span style="color: #333333;"> </span><span style="color: #A197BF;">t</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>beginTransaction();
<span style="color: #333333;">            </span><span style="color: #FFA070;">try</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">                </span><span style="color: #EF5C5F;">R</span><span style="color: #333333;"> </span><span style="color: #A197BF;">result</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>call.call();
<span style="color: #333333;">                </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(t.commit())<span style="color: #333333;"> </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>result;
<span style="color: #333333;">            </span>}<span style="color: #333333;"> </span><span style="color: #FFA070;">catch</span><span style="color: #333333;"> </span>(RuntimeException<span style="color: #333333;"> </span>|<span style="color: #333333;"> </span>Error<span style="color: #333333;"> </span>e)<span style="color: #333333;"> </span>{
<span style="color: #333333;">                </span>t.rollback();
<span style="color: #333333;">                </span><span style="color: #FFA070;">throw</span><span style="color: #333333;"> </span>e;
<span style="color: #333333;">            </span>}
<span style="color: #333333;">        </span>}
<span style="color: #333333;">    </span>}
}

<span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #FFA070;">class</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">TVar</span>&lt;<span style="color: #EF5C5F;">T</span>&gt;<span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #FFA070;">private</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">value</span>;
<span style="color: #333333;">    </span><span style="color: #FFA070;">private</span><span style="color: #333333;"> </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">ReadWriteLock</span><span style="color: #333333;"> </span><span style="color: #A197BF;">lock</span><span style="color: #333333;"> </span>=
<span style="color: #333333;">        </span><span style="color: #FFA070;">new</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">ReentrantReadWriteLock</span>();

<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1076;&#1083;&#1103;</span><span style="color: #333333;"> </span><span style="color: #637579;">rollback</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1074;</span><span style="color: #333333;"> </span><span style="color: #637579;">Transaction</span>
<span style="color: #333333;">    </span><span style="color: #FFA070;">private</span><span style="color: #333333;"> </span><span style="color: #FFA070;">static</span><span style="color: #333333;"> </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Object</span><span style="color: #333333;"> </span><span style="color: #A197BF;">UNDEFINED</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span><span style="color: #FFA070;">new</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Object</span>();
<span style="color: #333333;">    </span><span style="color: #FFA070;">private</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Object</span><span style="color: #333333;"> </span><span style="color: #A197BF;">oldValue</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>UNDEFINED;

<span style="color: #333333;">    </span><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">get</span>()<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span>lock.readLock().lock();
<span style="color: #333333;">        </span>Transaction.currentTransaction().addLock(lock.readLock());
<span style="color: #333333;">        </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>value;
<span style="color: #333333;">    </span>}

<span style="color: #333333;">    </span><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">void</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">set</span>(<span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">value</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(oldValue<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>UNDEFINED)<span style="color: #333333;"> </span>{
<span style="color: #333333;">            </span>lock.writeLock().lock();
<span style="color: #333333;">            </span><span style="color: #FFA070;">this</span>.oldValue<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span><span style="color: #FFA070;">this</span>.value;
<span style="color: #333333;">            </span>Transaction.currentTransaction().addWrite(<span style="color: #FFA070;">this</span>);
<span style="color: #333333;">        </span>}
<span style="color: #333333;">        </span><span style="color: #FFA070;">this</span>.value<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>value;
<span style="color: #333333;">    </span>}

<span style="color: #333333;">    </span><span style="color: #EF5C5F;">void</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">rollback</span>()<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span>value<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>(<span style="color: #EF5C5F;">T</span>)oldValue;
<span style="color: #333333;">        </span>oldValue<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>UNDEFINED;
<span style="color: #333333;">        </span>lock.writeLock().unlock();
<span style="color: #333333;">    </span>}
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-12-2" class="outline-4">
<h4 id="sec-1-12-2"><span class="section-number-4">1.12.2</span> Транзакции без блокировки</h4>
<div class="outline-text-4" id="text-1-12-2">
<p>
Предоставим реализацию без помех. Разные потоки могут бесконечно
долго мешать друг другу закончить транзакцию без прогресса, но если
активен только один поток, то прогресс гарантирован.
</p>

<p>
Проблематика &#x2013; даже читающие транзакции конфликтуют.  В этом
смысле решение с блокировкой лучше.
</p>

<div class="org-src-container">

<pre class="src src-java" id="obstruction-free"><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #FFA070;">class</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Transaction</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #FFA070;">private</span><span style="color: #333333;"> </span><span style="color: #FFA070;">static</span><span style="color: #333333;"> </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">ACTIVE</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>0;
<span style="color: #333333;">    </span><span style="color: #FFA070;">private</span><span style="color: #333333;"> </span><span style="color: #FFA070;">static</span><span style="color: #333333;"> </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">COMITED</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>1;
<span style="color: #333333;">    </span><span style="color: #FFA070;">private</span><span style="color: #333333;"> </span><span style="color: #FFA070;">static</span><span style="color: #333333;"> </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">ABORTED</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>-1;
<span style="color: #333333;">    </span><span style="color: #FFA070;">private</span><span style="color: #333333;"> </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">AtomicInteger</span><span style="color: #333333;"> </span><span style="color: #A197BF;">state</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span><span style="color: #FFA070;">new</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">AtomicInteger</span>(ACTIVE);

<span style="color: #333333;">    </span><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">boolean</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">isCommited</span>()<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>state.get()<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>COMMITED;
<span style="color: #333333;">    </span>}
<span style="color: #333333;">    </span><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">boolean</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">commit</span>()<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>state.compareAndSet(ACTIVE,<span style="color: #333333;"> </span>COMMITED);
<span style="color: #333333;">    </span>}
<span style="color: #333333;">    </span><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">void</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">rollback</span>()<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span>state.compareAndSet(ACTIVE,<span style="color: #333333;"> </span>ABORTED);
<span style="color: #333333;">    </span>}
<span style="color: #333333;">    </span><span style="color: #FFA070;">class</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">VarHolder</span>&lt;<span style="color: #EF5C5F;">T</span>&gt;<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Transaction</span><span style="color: #333333;"> </span><span style="color: #A197BF;">owner</span>;
<span style="color: #333333;">        </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Object</span><span style="color: #333333;"> </span><span style="color: #A197BF;">value</span>;
<span style="color: #333333;">        </span><span style="color: #EF5C5F;">Object</span><span style="color: #333333;"> </span><span style="color: #A197BF;">newValue</span>;<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">updated</span><span style="color: #333333;"> </span><span style="color: #637579;">by</span><span style="color: #333333;"> </span><span style="color: #637579;">owner</span>

<span style="color: #333333;">        </span><span style="color: #8AAFFA;">VarHolder</span>(<span style="color: #EF5C5F;">Transaction</span><span style="color: #333333;"> </span><span style="color: #A197BF;">owner</span>,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">Object</span><span style="color: #333333;"> </span><span style="color: #A197BF;">value</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">            </span><span style="color: #FFA070;">this</span>.owner<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>owner;
<span style="color: #333333;">            </span><span style="color: #FFA070;">this</span>.value<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>value;
<span style="color: #333333;">            </span><span style="color: #FFA070;">this</span>.newValue<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>value;
<span style="color: #333333;">        </span>}

<span style="color: #333333;">        </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1090;&#1077;&#1082;&#1091;&#1097;&#1077;&#1077;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1079;&#1072;&#1074;&#1080;&#1089;&#1080;&#1090;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1090;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1089;&#1086;&#1089;&#1090;&#1086;&#1103;&#1085;&#1080;&#1103;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1074;&#1083;&#1072;&#1076;&#1077;&#1083;&#1100;&#1094;&#1072;</span>
<span style="color: #333333;">        </span><span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">current</span>()<span style="color: #333333;"> </span>{
<span style="color: #333333;">            </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>owner.isCommited()<span style="color: #333333;"> </span>?<span style="color: #333333;"> </span>(<span style="color: #EF5C5F;">T</span>)newValue<span style="color: #333333;"> </span>:<span style="color: #333333;"> </span>(<span style="color: #EF5C5F;">T</span>)value;
<span style="color: #333333;">        </span>}
<span style="color: #333333;">    </span>}
}

<span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #FFA070;">class</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">TVar</span>&lt;<span style="color: #EF5C5F;">T</span>&gt;<span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #FFA070;">private</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">AtomicReference</span>&lt;<span style="color: #EF5C5F;">VarHolder</span>&lt;<span style="color: #EF5C5F;">T</span>&gt;&gt;<span style="color: #333333;"> </span><span style="color: #A197BF;">holder</span><span style="color: #333333;"> </span>=
<span style="color: #333333;">        </span><span style="color: #FFA070;">new</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">AtomicReference</span>&lt;<span style="color: #EF5C5F;">VarHolder</span>&lt;<span style="color: #EF5C5F;">T</span>&gt;&gt;();

<span style="color: #333333;">    </span><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">get</span>()<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>(<span style="color: #EF5C5F;">T</span>)open().newValue;
<span style="color: #333333;">    </span>}

<span style="color: #333333;">    </span><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">void</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">set</span>(<span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">value</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span>open().newValue<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>value;
<span style="color: #333333;">    </span>}

<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1077;&#1088;&#1077;&#1084;&#1077;&#1085;&#1085;&#1091;&#1102;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1085;&#1091;&#1078;&#1085;&#1086;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1090;&#1082;&#1088;&#1099;&#1090;&#1100;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1077;&#1088;&#1077;&#1076;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1083;&#1102;&#1073;&#1099;&#1084;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1076;&#1086;&#1089;&#1090;&#1091;&#1087;&#1086;&#1084;</span>
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">VarHolder</span>&lt;<span style="color: #EF5C5F;">T</span>&gt;<span style="color: #333333;"> </span><span style="color: #8AAFFA;">open</span>()<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #EF5C5F;">Transaction</span><span style="color: #333333;"> </span><span style="color: #A197BF;">tx</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>Transaction.current();
<span style="color: #333333;">        </span><span style="color: #EF5C5F;">VarHolder</span>&lt;<span style="color: #EF5C5F;">T</span>&gt;<span style="color: #333333;"> </span><span style="color: #A197BF;">old</span>,<span style="color: #333333;"> </span><span style="color: #A197BF;">upd</span>;
<span style="color: #333333;">        </span><span style="color: #FFA070;">do</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">            </span>old<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>holder.get();
<span style="color: #333333;">            </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(old.owner<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>tx)<span style="color: #333333;"> </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>old;
<span style="color: #333333;">            </span>old.owner.rollback();<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1077;&#1089;&#1083;&#1080;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1072;&#1082;&#1090;&#1080;&#1074;&#1077;&#1085;</span>
<span style="color: #333333;">            </span>upd<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span><span style="color: #FFA070;">new</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">VarHolder</span>&lt;<span style="color: #EF5C5F;">T</span>&gt;(tx,<span style="color: #333333;"> </span>old.current());
<span style="color: #333333;">        </span>}<span style="color: #333333;"> </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(!holder.compareAndSet(old,<span style="color: #333333;"> </span>upd));
<span style="color: #333333;">        </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>upd
<span style="color: #333333;">    </span>}
}
</pre>
</div>

<p>
Параллельно читать можно, для этого необходимо в <code>TVar</code> при чтении
не открывать переменную. Значение тогда сможет поменяться в
процессе транзакции, и линеаризуемость пропадает.
</p>

<p>
Решить это можно с помощью пост-проверки транзакции на
корректность. Или с помощью многоверсионного контроля корректности.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-13" class="outline-3">
<h3 id="sec-1-13"><span class="section-number-3">1.13</span> Мониторы и локи</h3>
<div class="outline-text-3" id="text-1-13">
<p>
Представим операцию как функцию над парой из состояния и
аргументов. Раньше мы рассматривали функции тлоько всюду
определенные.
</p>

<p>
Возьмем блокирующую очередь. Пусть <code>put</code> кладет только, если есть
место. Если нету, то она зависает, то есть put частично
определена. Аналогично предтсавим себе take, который может
вытаскивать элемент из очереди только, если очередь не пуста. Будем
поддерживать, с другой стороны, и не блокирующиеся операции &#x2013; <code>size</code>,
<code>offer</code>, <code>poll</code> (возвращает <code>null</code> если пуста).
</p>

<p>
Примечание: тут блокировка обозначает нечто другое &#x2013; определенность
функции.
</p>

<p>
Тут нужно переопределить линеаризуемость и исполнение:
</p>
<ol class="org-ol">
<li>\(inv(A)\) &#x2013; это вызов, но не всегда есть \(resp(A)\). \(A\) называется
незавершенной операцией, а \(inv(A)\) незавершенным вызовом.
</li>
<li>Исполнение линеаризуемо, если в исполнении можно:
<ul class="org-ul">
<li>Добавить такие ответы для незавершенных вызовов.
</li>
<li>Выкинуть остальные незавершенные вызовы.
</li>
<li>Можно упорядочить, получить допустимое последовательное
исполнение: \[inv(A₁) → resp(A₁) → ⋯ \]
</li>
</ul>
</li>
</ol>

<p>
<b>Монитор</b> &#x2013; это пара из mutex'а и набора условных переменных:
</p>
<ol class="org-ol">
<li>Взаимное исключение для защиты данных от одновременного изменения.
</li>
<li>Условные переменные для ожидания.
</li>
<li>Придумано Энтони Хоаром.
</li>
</ol>

<p>
В java каждый объект имеет монитор с одной условной переменной:
</p>
<ul class="org-ul">
<li><code>synchronized == monitorenter + monitorexit.</code>
</li>
<li><code>wait</code>, <code>notify</code>, <code>notifyAll</code> &#x2013; для работы с условной переменной.
</li>
</ul>

<p>
Что такое wait?
</p>
<ul class="org-ul">
<li>Может выходить из критической секции (монитора), чтобы другие
потоки могли в нее попасть и поменять состояние объекта
</li>
<li>Дожидается сигнала через условную переменную.
</li>
<li>Снова входит в критическую секцию (в монитор), чтобы этот поток
мог перепроверить состояние объекта и выполнить свою операцию если
состояние подходящее.
</li>
<li>Сигнал посылается через <code>notify</code> (сигнал одному ждущему потоку),
<code>notifyAll</code> (сигнал всем ждущим потокам).
</li>
</ul>

<div class="org-src-container">

<pre class="src src-java" id="java"><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #FFA070;">class</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">BlockingQueue</span>&lt;<span style="color: #EF5C5F;">T</span>&gt;<span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #FFA070;">private</span><span style="color: #333333;"> </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">T</span>[]<span style="color: #333333;"> </span><span style="color: #A197BF;">items</span>;
<span style="color: #333333;">    </span><span style="color: #FFA070;">private</span><span style="color: #333333;"> </span><span style="color: #FFA070;">final</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">n</span>;
<span style="color: #333333;">    </span><span style="color: #FFA070;">private</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">head</span>;
<span style="color: #333333;">    </span><span style="color: #FFA070;">private</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">tail</span>;

<span style="color: #333333;">    </span><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #FFA070;">synchronized</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">size</span>()<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>(tail<span style="color: #333333;"> </span>-<span style="color: #333333;"> </span>head<span style="color: #333333;"> </span>+<span style="color: #333333;"> </span>n)<span style="color: #333333;"> </span>%<span style="color: #333333;"> </span>n;
<span style="color: #333333;">    </span>}

<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1045;&#1089;&#1083;&#1080;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1095;&#1077;&#1088;&#1077;&#1076;&#1100;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1091;&#1089;&#1090;&#1072;,</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1074;&#1086;&#1079;&#1074;&#1088;&#1072;&#1097;&#1072;&#1077;&#1090;</span><span style="color: #333333;"> </span><span style="color: #637579;">null</span>
<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1086;&#1083;&#1085;&#1086;&#1089;&#1090;&#1100;&#1102;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1087;&#1088;&#1077;&#1076;&#1077;&#1083;&#1077;&#1085;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1074;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1083;&#1102;&#1073;&#1086;&#1084;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1089;&#1086;&#1089;&#1090;&#1086;&#1103;&#1085;&#1080;&#1080;</span>
<span style="color: #333333;">    </span><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #FFA070;">synchronized</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">poll0</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(head<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>tail)<span style="color: #333333;"> </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span><span style="color: #6F8FCC;">null</span>;
<span style="color: #333333;">        </span><span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">result</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>items[head];
<span style="color: #333333;">        </span>items[head]<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span><span style="color: #6F8FCC;">null</span>;
<span style="color: #333333;">        </span>head<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>(head<span style="color: #333333;"> </span>+<span style="color: #333333;"> </span>1)<span style="color: #333333;"> </span>%<span style="color: #333333;"> </span>n;
<span style="color: #333333;">        </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>result;
<span style="color: #333333;">    </span>}

<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1085;&#1077;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1087;&#1088;&#1077;&#1076;&#1077;&#1083;&#1077;&#1085;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1076;&#1083;&#1103;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1091;&#1089;&#1090;&#1086;&#1081;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1095;&#1077;&#1088;&#1077;&#1076;&#1080;</span>
<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1045;&#1089;&#1083;&#1080;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1095;&#1077;&#1088;&#1077;&#1076;&#1100;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1091;&#1089;&#1090;&#1072;</span><span style="color: #333333;"> </span><span style="color: #637579;">--</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1078;&#1076;&#1077;&#1090;.</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1050;&#1080;&#1076;&#1072;&#1077;&#1090;</span><span style="color: #333333;"> </span><span style="color: #637579;">exception</span><span style="color: #333333;"> </span><span style="color: #637579;">==</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1084;&#1086;&#1078;&#1077;&#1090;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1073;&#1083;&#1086;&#1082;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100;&#1089;&#1103;.</span>
<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1062;&#1080;&#1082;&#1083;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1079;&#1072;&#1095;&#1077;&#1084;?</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1057;&#1084;.</span><span style="color: #333333;"> </span><span style="color: #637579;">Object.wait:</span><span style="color: #333333;"> </span><span style="color: #637579;">spurious</span><span style="color: #333333;"> </span><span style="color: #637579;">wakeups</span><span style="color: #333333;"> </span><span style="color: #637579;">are</span><span style="color: #333333;"> </span><span style="color: #637579;">possible...</span>
<span style="color: #333333;">    </span><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #FFA070;">synchronized</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">poll</span><span style="color: #333333;"> </span><span style="color: #FFA070;">throws</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Interruptedexception</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(head<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>tail)<span style="color: #333333;"> </span>wait();<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1082;&#1088;&#1080;&#1090;&#1080;&#1095;&#1077;&#1089;&#1082;&#1072;&#1103;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1088;&#1072;&#1079;&#1085;&#1080;&#1094;&#1072;</span>
<span style="color: #333333;">        </span><span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">result</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>items[head];
<span style="color: #333333;">        </span>items[head]<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span><span style="color: #6F8FCC;">null</span>;
<span style="color: #333333;">        </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>((tail<span style="color: #333333;"> </span>+<span style="color: #333333;"> </span>1)<span style="color: #333333;"> </span>%<span style="color: #333333;"> </span>n<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>head)<span style="color: #333333;"> </span>notifyAll();<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1095;&#1077;&#1088;&#1077;&#1076;&#1100;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1073;&#1099;&#1083;&#1072;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1086;&#1083;&#1085;&#1072;</span>
<span style="color: #333333;">        </span>head<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>(head<span style="color: #333333;"> </span>+<span style="color: #333333;"> </span>1)<span style="color: #333333;"> </span>%<span style="color: #333333;"> </span>n;
<span style="color: #333333;">        </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>result;
<span style="color: #333333;">    </span>}

<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1057;&#1072;&#1084;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1084;&#1077;&#1090;&#1086;&#1076;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1085;&#1077;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1073;&#1083;&#1086;&#1082;&#1080;&#1088;&#1091;&#1077;&#1090;&#1089;&#1103;,</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1085;&#1086;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1073;&#1091;&#1076;&#1080;&#1090;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1086;&#1090;&#1086;&#1082;&#1080;,</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1082;&#1086;&#1090;&#1086;&#1088;&#1099;&#1077;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1078;&#1076;&#1091;&#1090;</span>
<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1086;&#1082;&#1072;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1095;&#1077;&#1088;&#1077;&#1076;&#1100;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1089;&#1090;&#1072;&#1085;&#1077;&#1090;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1085;&#1077;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1091;&#1089;&#1090;&#1072;</span>
<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1053;&#1091;&#1078;&#1085;&#1086;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1073;&#1091;&#1076;&#1080;&#1090;&#1100;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1076;&#1088;&#1091;&#1075;&#1080;&#1077;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1086;&#1090;&#1086;&#1082;&#1080;,</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1090;&#1086;&#1083;&#1100;&#1082;&#1086;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1077;&#1089;&#1083;&#1080;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1076;&#1077;&#1081;&#1089;&#1090;&#1074;&#1080;&#1090;&#1077;&#1083;&#1100;&#1085;&#1086;</span>
<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1095;&#1077;&#1088;&#1077;&#1076;&#1100;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1089;&#1090;&#1072;&#1085;&#1086;&#1074;&#1080;&#1090;&#1089;&#1103;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1085;&#1077;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1091;&#1089;&#1090;&#1072;.</span>
<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1057;&#1080;&#1075;&#1085;&#1072;&#1083;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1086;&#1081;&#1076;&#1077;&#1090;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1090;&#1086;&#1083;&#1100;&#1082;&#1086;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1086;&#1089;&#1083;&#1077;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1074;&#1099;&#1093;&#1086;&#1076;&#1072;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1080;&#1079;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1084;&#1086;&#1085;&#1080;&#1090;&#1086;&#1088;&#1072;</span><span style="color: #333333;"> </span><span style="color: #637579;">(&#1082;&#1088;&#1080;&#1090;&#1080;&#1095;&#1077;&#1089;&#1082;&#1086;&#1081;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1089;&#1077;&#1082;&#1094;&#1080;&#1080;).</span>
<span style="color: #333333;">    </span><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #FFA070;">synchronized</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">boolean</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">offer</span>(<span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">item</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">next</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>(tail<span style="color: #333333;"> </span>+<span style="color: #333333;"> </span>1)<span style="color: #333333;"> </span>%<span style="color: #333333;"> </span>n;
<span style="color: #333333;">        </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(next<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>head)<span style="color: #333333;"> </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span><span style="color: #6F8FCC;">false</span>;
<span style="color: #333333;">        </span>items[tail]<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>item;
<span style="color: #333333;">        </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(head<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>tail)<span style="color: #333333;"> </span>notifyAll();
<span style="color: #333333;">        </span>tail<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>next;
<span style="color: #333333;">    </span>}

<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1078;&#1076;&#1077;&#1090;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1086;&#1082;&#1072;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1095;&#1077;&#1088;&#1077;&#1076;&#1100;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1085;&#1077;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1086;&#1083;&#1085;&#1072;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1080;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1073;&#1091;&#1076;&#1077;&#1090;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1086;&#1090;&#1086;&#1082;&#1080;,</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1082;&#1086;&#1090;&#1086;&#1088;&#1099;&#1077;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1084;&#1086;&#1075;&#1091;&#1090;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1078;&#1076;&#1072;&#1090;&#1100;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1086;&#1082;&#1072;</span>
<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1095;&#1077;&#1088;&#1077;&#1076;&#1100;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1089;&#1090;&#1072;&#1085;&#1077;&#1090;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1085;&#1077;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1091;&#1089;&#1090;&#1072;</span>
<span style="color: #333333;">    </span><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #FFA070;">synchronized</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">void</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">put</span>(<span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">item</span>)<span style="color: #333333;"> </span><span style="color: #FFA070;">throws</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Interruptedexception</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(<span style="color: #6F8FCC;">true</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">            </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">next</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>(tail<span style="color: #333333;"> </span>+<span style="color: #333333;"> </span>1)<span style="color: #333333;"> </span>%<span style="color: #333333;"> </span>n;
<span style="color: #333333;">            </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(next<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>head)<span style="color: #333333;"> </span>{<span style="color: #333333;"> </span>wait();<span style="color: #333333;"> </span><span style="color: #FFA070;">continue</span>;<span style="color: #333333;"> </span>}
<span style="color: #333333;">            </span>items[tail]<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>item;
<span style="color: #333333;">            </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(head<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>tail)<span style="color: #333333;"> </span>notifyAll();
<span style="color: #333333;">            </span>tail<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>next;
<span style="color: #333333;">            </span><span style="color: #FFA070;">return</span>;
<span style="color: #333333;">        </span>}
<span style="color: #333333;">    </span>}

<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1074;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1084;&#1077;&#1090;&#1086;&#1076;&#1077;</span><span style="color: #333333;"> </span><span style="color: #637579;">take</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1090;&#1086;&#1078;&#1077;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1085;&#1091;&#1078;&#1085;&#1086;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1099;&#1090;&#1072;&#1090;&#1100;&#1089;&#1103;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1073;&#1091;&#1076;&#1080;&#1090;&#1100;</span><span style="color: #333333;"> </span><span style="color: #637579;">put,</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1082;&#1086;&#1075;&#1076;&#1072;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1084;&#1099;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1079;&#1072;&#1073;&#1088;&#1072;&#1083;&#1080;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1086;&#1089;&#1083;&#1077;&#1076;&#1085;&#1080;&#1081;</span>
<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090;</span>
}
</pre>
</div>

<p>
Рассмотрим еще раз разницу <code>notify</code> и <code>notifyAll</code>:
</p>
<ul class="org-ul">
<li>Нам нужно было использовать одну условную пееменную для двух
условий: очередь не пуста и очередь не полна, поэтому пользуемся
<code>notifyAll</code>.
</li>
<li>Если бы для каждого условия использовалась бы отдельная
переменная, <code>notify</code> было бы достаточно. Но у java есть только
одна условная переменная на каждый монитор.
</li>
</ul>

<p>
<code>j.u.c.ReentrantLock</code> спасает! Там есть методы всякие, которые
предоставляет интерфейс <code>Condition</code> с методами <code>await</code>, <code>signal</code>,
<code>signalAll</code>. Можно таким образом сделать эффективным <code>take</code>, в котом мы
делаем все то же самое, что с интерфейсом <code>wait/notify</code>, но на локе и
методами с похожими названиями. Но тут можно сделать два condition'а
и делать на каждом <code>signal</code>, а не <code>signalAll</code>.
</p>

<p>
У каждого потока есть флаг <code>interrupted</code>.
</p>
<ol class="org-ol">
<li>Его ставит метод <code>Thread.interrupt</code>.
</li>
<li>Его проверяют методы <code>wait</code>, <code>await</code> и так далее.
</li>
<li>В случае обнаружения выставленного эти методы:
<ul class="org-ul">
<li>Прекращают ждать.
</li>
<li>Сбрасывают флаг.
</li>
<li>Кидают <code>InterruptedException</code>.
</li>
</ul>
</li>
</ol>

<p>
Что делать с ненужным <code>InterruptedException</code>? Если нужно
реализовывать метод, который ждет, но не кидает
<code>InterruptedException</code>, то <code>interrupted</code> флаг надо
перевыставить. Тогда ожидание можно прерывать через
<code>Thread.interrupt</code>.
</p>

<p>
Частая ошибка в ббилиотеках &#x2013; забыли перевыставить <code>interrupted</code>
флаг.
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1074;&#1086;&#1079;&#1074;&#1088;&#1072;&#1097;&#1072;&#1077;&#1090;</span><span style="color: #333333;"> </span><span style="color: #637579;">null</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1077;&#1089;&#1083;&#1080;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1088;&#1077;&#1088;&#1074;&#1072;&#1083;&#1080;</span><span style="color: #333333;"> </span><span style="color: #637579;">InterruptedException</span>
<span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">takeOrNull</span>()<span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #FFA070;">try</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>take();
<span style="color: #333333;">    </span>}<span style="color: #333333;"> </span><span style="color: #FFA070;">catch</span><span style="color: #333333;"> </span>(<span style="color: #EF5C5F;">InterruptedException</span><span style="color: #333333;"> </span><span style="color: #A197BF;">e</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1077;&#1088;&#1077;&#1074;&#1099;&#1089;&#1090;&#1072;&#1074;&#1080;&#1084;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1092;&#1083;&#1072;&#1075;</span><span style="color: #333333;"> </span><span style="color: #637579;">interrupted</span>
<span style="color: #333333;">        </span>Thread.currentThread().interrupt();
<span style="color: #333333;">        </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span><span style="color: #6F8FCC;">null</span>;
<span style="color: #333333;">    </span>}
}
</pre>
</div>

<p>
Пишем поток, обрабатывающий очередь.
</p>
<ol class="org-ol">
<li>Заводим свой флаг, сигнализирующий что поток надо остановить. В
отличии от флага <code>interrupted</code>, нет риска что какой-то сторонний
метод его случайно сбросит.
</li>
<li>для прерывания ожиданий нужен <code>Thread.interrupt()</code>. <b>НИКОГДА</b> не
пользоваться <code>Thread.stop()</code>.
</li>
</ol>

<p>
Главный метод: метод run выполняется в отдельном потоке. Метод run
выходит в случае прерывания.
</p>
</div>
</div>
<div id="outline-container-sec-1-14" class="outline-3">
<h3 id="sec-1-14"><span class="section-number-3">1.14</span> SPSC очередь без блокировок и конвейер</h3>
<div class="outline-text-3" id="text-1-14">
<p>
Есть задачи и последовательные действия. \(A₁...Aₙ\) (типа посчитать
что-нибудь, преобразовать ответ, запаковать, записать в файл,..).
</p>

<p>
Пусть время выполнения действия \(Aᵢ\) равно \(tᵢ\). Тогда общее время
на задачу равно \(∑tᵢ\). Один поток в единицу времени выполняет
\(\frac{1}{∑tᵢ}\) задач.
</p>

<p>
Для увеличения пропускной способности сделаем конвейер на \(n\)
потоках.
</p>

<p>
Структура SPSC очереди.
</p>

<p>
Не блокирующийся <code>offer</code>: пишем без блокировок, поэтому важен порядок
действий и точки линеаризации операций.
CAS не нужен, только один producer меняет <code>tail</code>. Ожиданием займемся позже.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">boolean</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">offer</span>(<span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">item</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1095;&#1080;&#1090;&#1072;&#1077;&#1084;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1076;&#1080;&#1085;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1088;&#1072;&#1079;</span><span style="color: #333333;"> </span><span style="color: #637579;">tail</span><span style="color: #333333;"> </span><span style="color: #637579;">(&#1090;&#1086;&#1083;&#1100;&#1082;&#1086;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1084;&#1099;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1077;&#1075;&#1086;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1084;&#1077;&#1085;&#1103;&#1077;&#1084;)</span>
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">tail</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span><span style="color: #FFA070;">this</span>.tail;
<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1079;&#1076;&#1077;&#1089;&#1100;</span><span style="color: #333333;"> </span><span style="color: #637579;">volatile</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1095;&#1090;&#1077;&#1085;&#1080;&#1077;</span><span style="color: #333333;"> </span><span style="color: #637579;">head</span><span style="color: #333333;"> </span><span style="color: #637579;">(&#1077;&#1075;&#1086;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1084;&#1077;&#1085;&#1103;&#1077;&#1090;</span><span style="color: #333333;"> </span><span style="color: #637579;">consumer)</span>
<span style="color: #333333;">    </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(((tail+1)<span style="color: #333333;"> </span>&amp;<span style="color: #333333;"> </span>mask)<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>head)<span style="color: #333333;"> </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span><span style="color: #6F8FCC;">false</span>;<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1086;&#1083;&#1085;&#1072;</span>
<span style="color: #333333;">    </span>items[tail]<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>item;
<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1074;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1089;&#1072;&#1084;&#1086;&#1084;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1082;&#1086;&#1085;&#1094;&#1077;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1077;&#1088;&#1077;&#1076;&#1074;&#1080;&#1085;&#1077;&#1084;</span><span style="color: #333333;"> </span><span style="color: #637579;">tail</span>
<span style="color: #333333;">    </span><span style="color: #FFA070;">this</span>.tail<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>(tail<span style="color: #333333;"> </span>+<span style="color: #333333;"> </span>1)<span style="color: #333333;"> </span>&amp;<span style="color: #333333;"> </span>mask;<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">volatile</span><span style="color: #333333;"> </span><span style="color: #637579;">write</span>
<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;">        </span><span style="color: #637579;">^</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1101;&#1090;&#1086;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1090;&#1086;&#1095;&#1082;&#1072;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1083;&#1080;&#1085;&#1077;&#1072;&#1088;&#1080;&#1079;&#1072;&#1094;&#1080;&#1080;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1087;&#1077;&#1088;&#1072;&#1094;&#1080;&#1080;</span><span style="color: #333333;"> </span><span style="color: #637579;">offer</span>
<span style="color: #333333;">    </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span><span style="color: #6F8FCC;">true</span>;
}
</pre>
</div>

<ul class="org-ul">
<li><code>LockSupport.park</code> усыпляет текущий поток до тех пор:
<ul class="org-ul">
<li>Пока другой поток не вызовет <code>unpark</code>
</li>
<li>Что-то еще&#x2026;
</li>
</ul>
</li>
<li><code>LockSupport.unpark</code> делает ???
</li>
</ul>

<p>
Вот <code>offer</code> с <code>unpark</code>:
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">boolean</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">offer</span>(<span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">item</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">tail</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span><span style="color: #FFA070;">this</span>.tail;
<span style="color: #333333;">    </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(((tail+1)<span style="color: #333333;"> </span>&amp;<span style="color: #333333;"> </span>mask)<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>head)<span style="color: #333333;"> </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span><span style="color: #6F8FCC;">false</span>;<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1086;&#1083;&#1085;&#1072;</span>
<span style="color: #333333;">    </span>items[tail]<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>item;
<span style="color: #333333;">    </span><span style="color: #FFA070;">this</span>.tail<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>(tail<span style="color: #333333;"> </span>+<span style="color: #333333;"> </span>1)<span style="color: #333333;"> </span>&amp;<span style="color: #333333;"> </span>mask;<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">volatile</span><span style="color: #333333;"> </span><span style="color: #637579;">write</span>
<span style="color: #333333;">    </span>LockSupport.unpark(consumer);<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1088;&#1072;&#1079;&#1073;&#1091;&#1076;&#1080;&#1090;&#1100;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1078;&#1076;&#1091;&#1097;&#1077;&#1075;&#1086;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1086;&#1090;&#1088;&#1077;&#1073;&#1080;&#1090;&#1077;&#1083;&#1103;</span>
<span style="color: #333333;">    </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span><span style="color: #6F8FCC;">true</span>;
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">take</span>()<span style="color: #333333;"> </span><span style="color: #FFA070;">throws</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">InterruptedException</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1101;&#1090;&#1086;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1086;&#1084;&#1086;&#1078;&#1077;&#1090;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1088;&#1080;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1090;&#1083;&#1072;&#1076;&#1082;&#1077;</span>
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">assert</span><span style="color: #333333;"> </span>Thread.<span style="color: #A197BF;">currentThread</span>()<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>consumer;
<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1095;&#1080;&#1090;&#1072;&#1077;&#1084;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1076;&#1080;&#1085;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1088;&#1072;&#1079;</span><span style="color: #333333;"> </span><span style="color: #637579;">head</span>
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">head</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span><span style="color: #FFA070;">this</span>.head;<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">volatile</span><span style="color: #333333;"> </span><span style="color: #637579;">read</span>
<span style="color: #333333;">    </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(<span style="color: #6F8FCC;">true</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(Thread.interrupted())<span style="color: #333333;"> </span><span style="color: #FFA070;">throw</span><span style="color: #333333;"> </span><span style="color: #FFA070;">new</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">InterruptedException</span>();
<span style="color: #333333;">        </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1079;&#1076;&#1077;&#1089;&#1100;</span><span style="color: #333333;"> </span><span style="color: #637579;">volatile</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1095;&#1090;&#1077;&#1085;&#1080;&#1077;</span><span style="color: #333333;"> </span><span style="color: #637579;">tail</span><span style="color: #333333;"> </span><span style="color: #637579;">(</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1077;&#1075;&#1086;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1084;&#1077;&#1085;&#1103;&#1077;&#1090;</span><span style="color: #333333;"> </span><span style="color: #637579;">producer)</span>
<span style="color: #333333;">        </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(head<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>tail)<span style="color: #333333;"> </span>{<span style="color: #333333;"> </span>LockSupport.park();<span style="color: #333333;"> </span><span style="color: #FFA070;">continue</span>;<span style="color: #333333;"> </span>}
<span style="color: #333333;">        </span><span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">result</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>items[head];
<span style="color: #333333;">        </span>items[head]<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span><span style="color: #6F8FCC;">null</span>;
<span style="color: #333333;">        </span><span style="color: #FFA070;">this</span>.head<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>(head<span style="color: #333333;"> </span>+<span style="color: #333333;"> </span>1)<span style="color: #333333;"> </span>&amp;<span style="color: #333333;"> </span>mask;
<span style="color: #333333;">        </span>LockSupport.unpark(producer);
<span style="color: #333333;">        </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>result;
<span style="color: #333333;">    </span>}
}
</pre>
</div>

<p>
Блокирующийся <code>take</code> &#x2013; разбор:
</p>
<ul class="org-ul">
<li>Нужен цикл ожидания (park может проснуться сам).
</li>
<li>Нужно избежать ухода в бесконечный цикл.
</li>
</ul>

<p>
Блокирующийся <code>take</code> &#x2013; оптимальный <code>unpark</code>.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #FFA070;">public</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #8AAFFA;">take</span>()<span style="color: #333333;"> </span><span style="color: #FFA070;">throws</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">InterruptedException</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1101;&#1090;&#1086;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1086;&#1084;&#1086;&#1078;&#1077;&#1090;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1088;&#1080;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1090;&#1083;&#1072;&#1076;&#1082;&#1077;</span>
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">assert</span><span style="color: #333333;"> </span>Thread.<span style="color: #A197BF;">currentThread</span>()<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>consumer;
<span style="color: #333333;">    </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1095;&#1080;&#1090;&#1072;&#1077;&#1084;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1076;&#1080;&#1085;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1088;&#1072;&#1079;</span><span style="color: #333333;"> </span><span style="color: #637579;">head</span>
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">head</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span><span style="color: #FFA070;">this</span>.head;<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">volatile</span><span style="color: #333333;"> </span><span style="color: #637579;">read</span>
<span style="color: #333333;">    </span><span style="color: #FFA070;">while</span><span style="color: #333333;"> </span>(<span style="color: #6F8FCC;">true</span>)<span style="color: #333333;"> </span>{
<span style="color: #333333;">        </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(Thread.interrupted())<span style="color: #333333;"> </span><span style="color: #FFA070;">throw</span><span style="color: #333333;"> </span><span style="color: #FFA070;">new</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">InterruptedException</span>();
<span style="color: #333333;">        </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1079;&#1076;&#1077;&#1089;&#1100;</span><span style="color: #333333;"> </span><span style="color: #637579;">volatile</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1095;&#1090;&#1077;&#1085;&#1080;&#1077;</span><span style="color: #333333;"> </span><span style="color: #637579;">tail</span><span style="color: #333333;"> </span><span style="color: #637579;">(</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1077;&#1075;&#1086;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1084;&#1077;&#1085;&#1103;&#1077;&#1090;</span><span style="color: #333333;"> </span><span style="color: #637579;">producer)</span>
<span style="color: #333333;">        </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(head<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>tail)<span style="color: #333333;"> </span>{<span style="color: #333333;"> </span>LockSupport.park();<span style="color: #333333;"> </span><span style="color: #FFA070;">continue</span>;<span style="color: #333333;"> </span>}
<span style="color: #333333;">        </span><span style="color: #EF5C5F;">T</span><span style="color: #333333;"> </span><span style="color: #A197BF;">result</span><span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>items[head];
<span style="color: #333333;">        </span>items[head]<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span><span style="color: #6F8FCC;">null</span>;
<span style="color: #333333;">        </span><span style="color: #FFA070;">this</span>.head<span style="color: #333333;"> </span>=<span style="color: #333333;"> </span>(head<span style="color: #333333;"> </span>+<span style="color: #333333;"> </span>1)<span style="color: #333333;"> </span>&amp;<span style="color: #333333;"> </span>mask;<span style="color: #333333;"> </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">volatile</span><span style="color: #333333;"> </span><span style="color: #637579;">write</span>
<span style="color: #333333;">        </span><span style="color: #637579;">//</span><span style="color: #333333;">        </span><span style="color: #637579;">^</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1101;&#1090;&#1086;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1090;&#1086;&#1095;&#1082;&#1072;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1083;&#1080;&#1085;&#1077;&#1072;&#1088;&#1080;&#1079;&#1072;&#1094;&#1080;&#1080;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1087;&#1077;&#1088;&#1072;&#1094;&#1080;&#1080;</span><span style="color: #333333;"> </span><span style="color: #637579;">take</span>
<span style="color: #333333;">        </span><span style="color: #637579;">//</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1077;&#1089;&#1083;&#1080;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1095;&#1077;&#1088;&#1077;&#1076;&#1100;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1073;&#1099;&#1083;&#1072;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1086;&#1083;&#1085;&#1072;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1076;&#1086;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1087;&#1077;&#1088;&#1072;&#1094;&#1080;&#1080;</span><span style="color: #333333;"> </span><span style="color: #637579;">(producer</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1084;&#1086;&#1075;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1089;&#1087;&#1072;&#1090;&#1100;)</span>
<span style="color: #333333;">        </span><span style="color: #FFA070;">if</span><span style="color: #333333;"> </span>(((takl<span style="color: #333333;"> </span>+<span style="color: #333333;"> </span>1)<span style="color: #333333;"> </span>&amp;<span style="color: #333333;"> </span>mask)<span style="color: #333333;"> </span>==<span style="color: #333333;"> </span>head)<span style="color: #333333;"> </span>LockSuppor.unpark(producer);
<span style="color: #333333;">        </span><span style="color: #FFA070;">return</span><span style="color: #333333;"> </span>result;
<span style="color: #333333;">    </span>}
}
</pre>
</div>

<ul class="org-ul">
<li>Все остальные операции аналогично.
</li>
<li>Оптимизации SPSC очереди.
<ul class="org-ul">
<li>Блочная работа - можно доставать сразу несколько задач.
</li>
<li>Обобщается на конвейер из n потоков.
<ul class="org-ul">
<li>\(n\) потоков, работающие в конвейере, будут использовать общий
циклический буфер.
</li>
<li>Кладем задачу в буфер первым действием
</li>
<li>Удалем задачу из буфера последним действием
</li>
<li>У каждого потока есть свой <code>index</code> в буфере, а с \(n = 2\) было
<code>tail == producer index, head == consumer index</code>.
</li>
<li>Каждый поток работает над задачами до <code>index</code> предыдущего потока
в конвейере и следит, чтобы не упереться в следующий.
</li>
</ul>
</li>
</ul>
</li>
</ul>

<p>
Практические наблюдения про конвейеры:
</p>
<ul class="org-ul">
<li><b>Конвейер</b> (<i>pipeline</i>) имеет смысл, если отдельные действия по
задаче примерно равны по продолжительности
</li>
<li>Есть накладный расход на организацию. На быстрых действиях не выгодно.
</li>
<li>Накладной расход на задачу можно уменьшить, обрабатывая элемениты
пачками (<i>batching</i>).
</li>
<li>Конвейер повышает <b>пропускную способность</b> (<i>throughput</i>) принося
в жертву <b>задержку</b> (<i>latency</i>) &#x2013; время обработки одной задачи от
начала до конца.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Распределенные системы</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Билеты</h3>
<div class="outline-text-3" id="text-2-1">
<ol class="org-ol">
<li>Логические часы Лампорта и векторные часы, их свойства
</li>
<li>Часы с прямой зависимостью (и их свойства) и матричные часы.
</li>
<li>Взаимное исключение в распределенной системе. Централизованный
алгоритм.
</li>
<li>Взаимное исключение в распределенной системе. Алгоритм Лампорта,
</li>
<li>Взаимное исключение в распределенной системе. Алгоритм Рикарта и
Агравалы.
</li>
<li>Взаимное исключение в распределенной системе. Алгоритм обедающих
философов.
</li>
<li>Взаимное исключение в распределенной системе. Алгоритм на основе
токена.
</li>
<li>Взаимное исключение в распределенной системе. Алгоритмы основе
кворума (простое большинство, рушащиеся стены).
</li>
<li>Согласованное глобальное состояние (согласованный
срез). Алгоритм Чанди-Лампорта. Запоминание сообщений на стороне
отправителя.
</li>
<li>Согласованное глобальное состояние (согласованный
срез). Алгоритм Чанди-Лампорта. Запоминание сообщений на
стороне получателя.
</li>
<li>Глобальные свойства. Стабильные и нестабильные
предикаты. Слабый конъюнктивный предикат. Централизованный
алгоритм.
</li>
<li>Слабый конъюнктивный предикат. Распределенный алгоритм.
</li>
<li>Диффундирующие вычисления. Останов. Алгоритм Дейксты и Шолтена.
</li>
<li>Локально-стабильные предикаты, согласованные интервалы,
барьерная синхронизация (3 алгоритма). Применение для
определения взаимной блокировки.
</li>
<li>Упорядочивание сообщений. Определения, иерархия
порядков. Алгоритм для FIFO.
</li>
<li>Упорядочивание сообщений. Определения, иерархия
порядков. Алгоритм для причинно-согласованного порядка.
</li>
<li>? Упорядочивание сообщений. Определения, иерархия
порядков. Алгоритм для синхронного порядка.
</li>
<li>Общий порядок (total order). Алгоритм Лампорта.
</li>
<li>Общий порядок (total order). Алгоритм Скина.
</li>
<li>Иерархия ошибок в распределенных системах. Отказ узла в
асинхронной системе &#x2014; невозможность консенсуса
(доказательство Фишера-Линча-Патерсона).
</li>
<li>Консенсус в распределенных системах. Применение консенсуса:
выбор лидера, terminating reliable broadcast.
</li>
<li>Синхронные системы. Алгоритм для консенсуса в случае отказа
заданного числа узлов.
</li>
<li>Синхронные системы. Проблема византийских генералов. Алгоритм
для N &gt;= 4, f = 1. Объяснить идею обобщения для f &gt; 1.
</li>
<li>Синхронные системы. Проблема византийских
генералов. Невозможность решения при N = 3, f = 1.
</li>
<li>Недетерминированные алгоритмы консенсуса. Алгоритм Бен-Ора.
</li>
<li>Paxos. Алгоритм, его свойства. Основные модификации.
</li>
<li>Транзакции в распределенных системах. 2 Phase Locking, 2 Phase
Commit.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Вступление</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Чем отличается курс от предыдущего? Типа будем изучать модели,
которые обмениваются сообщениями. Это можно сэмулировать на том,
что мы проходили в предыдущем курсе, но это неэффективно. А хочется
быстро, типа как в <code>NUMA</code> там или вот эти все <code>MOESI</code> (но
когерентные кеши &#x2013; это параллельная система, а не распределенная).
</p>

<p>
Все короче распределенное в eтом мире поетому предмет оче важный и
интересный!
</p>

<p>
Система масштабируется вертикально, если мы даем ей больше ядер и
она быстрее работает. Система масштабируется горизонтально, если
от большего количества машин становится лучше.
</p>

<p>
Важные отличия распределенных систем:
</p>
<ol class="org-ol">
<li>Нельзя полагаться на общее время или общее состояние системы &#x2013;
оно постоянно меняется.
</li>
<li>Географически распределена.
</li>
<li>Обмен сообщениями, а не общая память.
</li>
<li>Может отказать частично.
</li>
<li>Больше надежность, сложно кодить, меньше стоит.
</li>
</ol>

<p>
Модель:
</p>
<ul class="org-ul">
<li>Проессы \(P,Q,R ... ∈ ℙ\)
</li>
<li>События \(a,b,c,d,e... ∈ E\), в процессах \(proc(e) ∈ P\).
</li>
<li>Сообщения \(m ∈ M\), события посылки/приема \(snd(m),rev(m) ∈ E\).
</li>
<li>Произошло-до между событиями (\(→\)):
<ul class="org-ul">
<li>Минимальный строгий частичный порядок, что
<ul class="org-ul">
<li>если \(e\) и \(f\) произошли в одном процессе и \(e < f\) (e шло перед
f), то \(e → f\).
</li>
<li>если \(m\) сообщение, то \(snd(m) → rcv(m)\).
</li>
</ul>
</li>
<li>Другими словами &#x2013; транзитивное замыкание порядка событий на
процессе и посылке/приема сообщений.
</li>
</ul>
</li>
</ul>

<p>
Графическая нотация &#x2013; параллельные горизонтальные линии как
потоки, стрелочки между узлами на них как передчи сообщений, вот
ето все.
</p>

<p>
Логические часы: для каждого события e определим число \(C(e)\) так,
что: \(∀e,f ∈ E:e → f ⇒ C(e) < C(f)\).
</p>

<p>
Такая функция \(C\) называется логичксеими часами. В обратную сторону
отношение не верно и не может быть, потому что порядок на числах
полный, а произошло-до &#x2013; частичный.
</p>

<p>
<b>Логические часы Лампорта</b>: время это функция \(C(e)\), где \(e\) &#x2013;
событие, в каждом процессе.
</p>

<p>
Алогоритм:
</p>
<ul class="org-ul">
<li>Перед каждой посылкой увеличивает \(C\) на единицу.
</li>
<li>При посылке сообщения процесс посылает свое время \(C\).
</li>
<li>При приеме сообщения делаем \(C := max(received_C, C) + 1\).
</li>
</ul>

<p>
Очевидно логические часы Лампорта являются логическими часами.
События в одинаковое логическое время параллельны.
</p>

<p>
<b>Векторные часы</b>: для каждого события e определим вектор \(VC(e)\) так,
что \(∀e,f ∈ E: e → f ⇔  VC(e) < VC(f)\).
</p>

<p>
Сравнение векторов происходит покомпонентно (не лексикографически).
Такая функция будет называтеся векторными часами.
</p>

<p>
Алгоритм векторного времени: время это целочисленный вектор
\(VC\). Будем по посылке инкрементировать, по посылке отправлять, а при
приеме делаем покомпонентно \(VC: = max(received_VC, VC)\).
</p>

<p>
При этом важно: \(∀e,f ∈ E: proc(e) = Pᵢ, proc(f) = Pⱼ : e → f ⇔
   (VC(e)ᵢ,VC(e)ⱼ) < (VC(f)ᵢ, VC(f)ⱼ)\). Типа хватает только двух
сравнений. Если процессы параллельны, то вектора будут несравнимы.
</p>

<p>
<b>Часы с прямой зависимостью</b> (<i>direct dependency</i>): храним вектор, а
посылает только одно число: \(∀e,f ∈ E: e →_d f ⇔ VC_d(e) <
   VC_d(f)\), где \(e →_d f ⇔ e < f ∨ ∃m ∈ M: e ≤ snd(m) ∧ rcv(m) ≤
   f\). Менее формально, \(e →_d f\) значит произошло-до суженное на один
процесс либо на два процесса \(P\) и \(Q\) (\(e ∈ P, d ∈ Q\), соединенных
сообщением от \(Q\) к \(P\)).
</p>

<p>
Формально это комбинация Лампорта и векторного.
</p>

<p>
<b>Матричные часы</b>: храним матрицу, посылаем тоже матрицу. В отличии
от векторных часов, дополнительное пространство позволяет процессу
\(M\) знать, что процесс \(P\) знает о процессе \(Q\) (в то время, как
векторные часы представляют собой знание процесса \(M\) о процессе
\(P\)). Скажем, если \(∀i, s.[i,s.p] > k\), то процесс \(s.p\) может
утверждать, что все знают, что его состояние больше \(k\).
</p>

<p>
<b>Взаимное исключение</b> в распределенных системах:
</p>
<ol class="org-ol">
<li>Критическая секция \(CSᵢ\) состоит из двух событий:
<ul class="org-ul">
<li>\(Enter(CSᵢ)\) &#x2013; вход
</li>
<li>\(Exit(CSᵢ)\) &#x2013; выход
</li>
<li>\(i\) &#x2013; порядковый номер захода в критическую секцию
</li>
</ul>
</li>
<li>Основное требование: <b>взаимное исключение</b>: два процесса не
должны быть в критической секции одновременно, то есть \(Exit(CSᵢ)
      → Enter(CSᵢ₊₁)\).
</li>
</ol>

<p>
Также в системах с общей памятью нужны доп требования <i>прогресса</i>:
</p>
<ul class="org-ul">
<li>Минимальное требование &#x2013; каждое желание процесса попасть в
критическую секцию будет рано или поздно удовлетворено.
</li>
<li>Также может быть гарантирован тот или иной уровень честности
удовлетворения желаний процессов о входе в крит. секцию.
</li>
</ul>


<p>
Алгоритмы взаимного исключения (хотим что-то делать в критической
секции):
</p>
<ol class="org-ol">
<li>Централизованный алгоритм:
<ul class="org-ul">
<li>Выделенный координатор
</li>
<li>Три типа сообщений:
<ul class="org-ul">
<li><code>req[uest]</code> &#x2013; от запрашиваающего процесса координатору
</li>
<li><code>ok</code> &#x2013; от координатора
</li>
<li><code>rel[ease]</code> &#x2013; после выхода из критической секции
</li>
</ul>
</li>
<li>Требует 3 сообщения на критическую секцию независимо от
количества участвующих процессов
</li>
<li>Не масштабируется из-за необходимости иметь выделенного
координатора.
</li>
<li>Подход шаринга &#x2013; это короче сделать несколько координаторов и
пользоваться ими. Но это не решает проблему надежности &#x2013; если
падает один координатор, то его часть данных, за которую он
отвечает, становится недоступна.
</li>
</ul>
</li>
<li>Алгоритм Лампорта (\(3N-3\) сообщения). Устроен как
централизованый, но на основе логических часов (векторных с
прмяой зависимостью).

<p>
Каждый процесс хранит очередь всех билетиков на запрос, то есть
некоторую очередь.
</p>

<p>
Процесс, который хочет зайти в критическую секцию, добавляет
себя в конец своей очереди и посылает <code>req</code> всем другим
процессам. Процесс, принимающий <code>req</code> делает следующее: если он
принимает два <code>req</code> с одинаковыми часами, то упорядочиваем их по
номеру процесса. Первому запросу отвечают <code>ok</code> с меткой времени.
</p>

<p>
Когда процесс получает <code>ok</code> от всех, то он входит в критическую
секцию, если его запрос всем остальным был сделан раньше. Типа
отправил раньше чем все другие обработали.
</p>

<p>
После выхода из критической секции всем посылается <code>rel</code>. Те,
кто получают <code>rel</code>, удаляют соответствующий вектор из очереди.
</p>

<p>
Этот алгоритм сильно основан на FIFO: любые два сообщения от
одного потока другому должны придти в порядке отправления.
</p>
</li>
<li>Алгоритм Рикарда и Агравалы (\(2N-2\) сообщения, starvation free).

<p>
Модификация алгоритма Лампорта: давайте не будем отсылать <code>ack</code>
на <code>req</code> если мы работаем в критической секции. Объединим
acknowledge и release в одно сообщение <code>okay</code>. Когда процесс
хочет войти в критическую секцию, он рассылает всем <code>okay</code> и
ждет, пока все ему напишут <code>okay</code>.
</p>

<p>
По получении <code>okay</code> от кого-то:
</p>
<ol class="org-ol">
<li>Если ничего не хочет &#x2013; отправляет <code>okay</code> обратно.
</li>
<li>Если уже послал запрос &#x2013; сравнивает свой запрос (метку
времени) с пришедшей (+ еще сравнение по номеру потока) и
если пришедшая больше (позже), отвечает <code>okay</code>.
</li>
<li>Иначе задерживает ответ (кладет в очередь).
</li>
</ol>
<p>
После выхода из критической секции рассылает все задержанные
отклики.
</p>
</li>
<li>Алгоритм обедающих философов (от \(0\) до \(2N-2\) сообщений).
Проблема предыдущих алгоритмов в том, что они посылают сообщения
потокам, которые потенциально могут вообще не хотеть войти в
критическую секцию.

<p>
Пусть есть \(n\) процессов и между соседними есть какие-то
конфликты памяти (в задаче философов граф конфликтов &#x2013; колесо, а
в общем случае граф может быть любым). Ориентируем граф
конфликтов так, чтобы в нем не оказалось циклов. Если нет
входящих ребер (мы &#x2013; исток), тогда будем брать ресурсы. После
использования ресурсов все исходящие ребра перевернем. Две
теоремы из теории графов, которые гарантируют корректность:
</p>
<ol class="org-ol">
<li>в графе без циклов можно истоки инвертировать и циклов не
образуется.
</li>
<li>в графе без циклов есть исток.
</li>
</ol>
<p>
Ресурсы могут быть чистыми и грязными. Задача &#x2013; собрать все
чистые ресурсы. Грязные ресурсы получаются после
использования. Если приходит запрос на грязный ресурс, мы его
чистим и отдаем.
</p>

<p>
Как инициализировать граф? У потоков есть идентификаторы. Можно
посортить с помощью них &#x2013; граф отсортированный таким образом не
будет иметь циклов (топсорт).
</p>

<p>
Можно решить эту задачу и рандомно &#x2013; хватать какие-то ресурсы,
если не получилось, отдаем и ждем какое-то рандомное количество
времени.
</p>
</li>
<li>Алгоритм на основе токена.

<p>
Работает в системах, где связь кольцевая. Процесс будет выполнять
критическую секцию только когда у него есть токен. После
использования токена или если делать ничего не нужно, токен
отправляется по кольцу дальше.
</p>

<p>
Как раз ethernet работает как рандомизированные философы с полным
графом, а token ring вот делал кольцевую передачу данных,
отцепляя от информации ту, которая нужна конкретно одному
компуктеру.
</p>
</li>
<li>Алгоритмы на основе кворума.

<p>
Будем спрашивать только подмножество процессов. Кворум: \(Q ⊂ 2ᵖ\):
\(∀A,B ∈ Q: A∩B ≠ ∅\). Также кворум должен быть замкнут по
надмножеству.
</p>

<ul class="org-ul">
<li>Централизованный кворум &#x2013; одна машина.
</li>
<li>Простое большинство (вес каждого узла единица) и взвешенное
большинство (веса произвольны).
</li>
<li>Рушащиеся стены &#x2013; упорядочиваем все процессы в прямоугольник
(по возможности), тогда кворумом является любая прямая и по
одному представителю из каждой другой параллельной линии.
</li>
</ul>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> Глобальные состояния и срезы</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Хотим уметь запоминать состояние распределенной системы, чтобы
можно было ее восстановить в случае каких-либо проблем.
</p>

<ul class="org-ul">
<li><b>Срез</b> &#x2013; такое \(G ⊂ E\), что \(∀f ∈ G, e ∈ E, e < f ⇒ e ∈ G\).
</li>
<li><b>Согласованный срез</b> &#x2013; срез \(G\), что \(∀f ∈ G, e ∈ E: e → f ⇒ e ∈
     G\).
</li>
</ul>

<p>
<a href="http://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%A7%D0%B0%D0%BD%D0%B4%D0%B8-%D0%9B%D0%B0%D0%BC%D0%BF%D0%BE%D1%80%D1%82%D0%B0">Алгоритм Чанди Лампорта на neerc.ifmo.ru</a>
</p>

<p>
<b>Алгоритм Чанди-Лампорта</b> для согласованного запоминания глобального
состояния системы (получения согласованного среза):
</p>
<ol class="org-ol">
<li>Есть инициатор (observer), который запоминает свое состояние
(становится красным), посылает токен всем другим потокам.
</li>
<li>При получении токена <i>первый раз</i> процесс запоминает свое
состояние (становится красным), посылает свое состояние
инициатору и в дальнейшем прикрепляет красный маркер к всем
сообщениям.
</li>
<li>Чтобы восстановить работу системы из запомненного состояния
(<i>checkpoint</i>) надо еще запоминать сообщения в пути.
Запоминание сообщений: нужно запомнить все сообщения \(m\) такие
что \(snd(m) ∈ G ∧ rcv (m) ∈ E \ G\), где \(G\) &#x2013; согласованный
срез.
</li>
<li>Когда красный процесс получает сообщение от белого процесса (без
токена), то процесс форвардит сообщение инициатору (или хранит у
себя). Это называется запоминание <b>на стороне получателя</b>.
</li>
<li><b>На стороне отправителя</b>: пока ты белый, запоминаешь все посланные
запросы. Если кто-то отправил на запрос ack, то сообщение можно
удалять. Когда кто-то становится красным, то он отправляет
отправителю всех сообщений, что хранит, красный ack, и тот их
удаляет из себя.
</li>
<li>Запомненные состояния образуют согласованный срез, если
сообщения между процессами идут FIFO. В ином случае с сообщением
следует отправлять цвет отправителя, а белых процессов обязать
становиться красными при получении сообщения от красного.
</li>
</ol>

<p>
<b>Глобальные свойства</b>:
</p>
<ul class="org-ul">
<li>Стабильные предикаты
<ul class="org-ul">
<li>Берем согласованные срезы; если предикат верен, то будет верен
и в дальнейшем. С другой стороны, строить согласованный срез
дорого &#x2013; \(O(n²)\) сообщений.
</li>
<li>Пример &#x2013; потеря токена, взаимная блокировка,..
</li>
</ul>
</li>
<li>Нестабильные предикаты
<ul class="org-ul">
<li>Локальный предикат &#x2013; предикат по состоянию одного процесса.
</li>
<li>Если предикат есть дизъюнкция локальных предикатов, то
вычисление легко, достаточно найти хотя бы один верный.
</li>
<li>С конъюнкцией все неочевидно &#x2013; как найти правильный срез?
</li>
</ul>
</li>
</ul>

<p>
Если предикат \(P\) имеет вид конъюнкции локальных предикатов над
состоянием каждого процесса: \(P = L₁∧L₂∧...∧Lₙ\), и его истинность
есть истинность хотя бы на одном срезе, то такой предикат
называется слабым конъюктивным. Как пример
предиката &#x2013; "в системе нет координатора", причем локальное условие
&#x2013; "я не координатор".
</p>

<p>
Сложные предикаты, являющиеся логической комбинацией локальных
предикатов, всегда можно представить в нормальной дизъюнктивной
форме и рассматривать как дизъюнкцию слабых конъюнктивных
предикатов.
</p>

<p>
Слабый конъюнктивный предикат: <b>централизованный алгоритм</b>.
</p>
<ul class="org-ul">
<li>Каждый работающий процесс отслеживает свое векторное время \(VC\).
</li>
<li>При наступлении истинности локального предиката \(L\) увеличиваем
свою компоненту, посылаем сообщение координатору \(C\), указывая
векторное время когда это произошло.
</li>
<li>Любой срез итого задается вектором.
<ul class="org-ul">
<li>Координатор поддерживает в памяти <i>срез-кандидат</i> и очередь
необработанных сообщений от каждого процесса.
</li>
<li>Срез кандидат согласован тогда и только тогда когда все
соответствующие вектора попарно несравнимы.
</li>
</ul>
</li>
<li>Координатор хранит вектора среза-кандидата и флажок для каждой
его компоненты: красный &#x2013; этот элемент не может быть частью
согласованного среза, зеленый &#x2013; может.
</li>
<li>Начальное состояние &#x2013; все по нулям, красные.
</li>
<li>Обрабатываем приходящие сообщения только от красных процессов,
сообщения от зеленых ставим в очередь.
<ul class="org-ul">
<li>Сравниваем пришедший вектор попарно с другими процессами, если
новый вектор больше, то делаем меньший процесс красным.
</li>
<li>После обработки сообщения делаем процесс зеленым.
</li>
</ul>
</li>
<li>Если все зеленое, то мы нашли согласованный срез.
</li>
</ul>

<p>
<b>Распределенный алгоритм</b> для проверки слабого конъюнктивного
предиката:
</p>
<ul class="org-ul">
<li>Каждый процесс имеет своего собственного координатора
</li>
<li>Процессы шлют те же сообщения своим координаторам.
</li>
<li>Координаторы пересылают друг другу срезы-кандидаты и флажки
(отсылают информацию о своем процессе, запоминают информацию о
других).
</li>
<li>Красные координаторы (координаторы красных процессов)
обрабатывают сообщения от своих процессов.
<ul class="org-ul">
<li>После обработки сообщение становится зеленым.
</li>
<li>Если в процессе обработки они пометили красным другой процесс,
то шлют сообщение его координатору.
</li>
</ul>
</li>
<li>Если координатор замечает момент, в котором ему рассказали о всех
зеленых чуваках и его парень тоже зелен, и никто не сравним &#x2013;
тогда он победил.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> Диффундирующие вычисления</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>Процесс-environment, начинает вычисление
</li>
<li>Процессы в системе активные или пассивные, можно стать активным
только по получении сообщения. Стать пассивным можно всегда.
</li>
<li>Только активные процессы могут слать сообщения.
</li>
</ul>

<p>
Алгоритм Дейкстры-Шолтена &#x2013; способ определить, что диффундирующее
вычисление завершено. Будем думать, что каждый порожденный активный
процесс сообщением есть сын того, кто его разбудил. Тогда в общем
случае, если граф &#x2013; дерево:
</p>
<ol class="org-ol">
<li>Cыновья должны пинговаться о том, что они живы.
</li>
<li>Если процесс ничего не считает, он отвечает на запрос
отрицательно.
</li>
<li>Когда процесс не имеет детей и ничего не считает, он оповещает
родителя об этом.
</li>
<li>Когда корень дерева в ситуации 3, вычисление окончено.
</li>
</ol>

<p>
Алгоритм логично продолжается на ациклические графы, надо хранить
количество запросов, которые в тебя поступили и количество
ответов. Когда разность ноль &#x2013; говорим всем, что отключаемся.
</p>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> Локальная стабильность, баръерные синхонизации</h3>
<div class="outline-text-3" id="text-2-5">
<ul class="org-ul">
<li><b>Локально-стабильный</b> предикат &#x2013; такой, что если он выполняется
для какого-то среза, то и дальше тоже выполняется.
</li>
<li>Интвервал &#x2013; пара срезов \([X, Y]\), таких что \(X ⊂ Y\).
</li>
<li>Пусть \(G\) и \(H\) срезы, тогда \([X, Y]\) согласован, если \(∀e,f : (f
     ∈ X) ∧ (e → f) ⇒ e ∈ Y\). Все, что случилось до любого события из
\(X\) есть в \(Y\). Иное определение согласованности интервала, что
\(∃G\) &#x2013; согласованый, такой что \(X ⊂ G ⊂ Y\).
</li>
<li>\([X,Y]\) баръерно-синхронизирован, если \(∀g ∈ X ∧ h ∉ Y: g →
     h\). Интуитивно, каждое событие в \(X\) было выполнено перед каждым
событием не из \(Y\). Короче это каким-то образом мы сжали
happens-before, так что все прошлое связано с будущим.
</li>
<li>Достижение баръерной синхронизации (будем искать такие \(X\) и \(Y\)):
<ol class="org-ol">
<li>По кольцу &#x2013; сверху до низу и обратно.
</li>
<li>Все всем сразу.
</li>
<li>Все координатору, потом координатор всем.
</li>
</ol>
</li>
</ul>

<p>
Чтобы проверить, что локально-стабильный предикат выполняется,
достаточно взять любые два среза до \(X\) и после \(Y\) и сравнить.
</p>

<p>
Детектить дедлоки можно так: каждый процесс знает, кого ждет. Также
у каждого процесса есть \(bool\) переменная \(changed\), которая
означает, поменялись ли ожидания с предыдущего запроса. Координатор
опрашивает каждый поток, спрашивая, кого он ждет, строит граф. Если
видет в нем цикл, повторяет еще раз, спрашивая, поменялось ли
что-то. Если не поменялось, то дедлок. Поскольку координатор
спрашивает всех два раза, он делает баръерную синхронизацию.
</p>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6"><span class="section-number-3">2.6</span> Упорядочивания событий</h3>
<div class="outline-text-3" id="text-2-6">
<p>
Какие есть упорядочивания событий:
</p>
<ul class="org-ul">
<li>Для обычных сообщений между парой процессов (<i>unicast</i>):
<ul class="org-ul">
<li>Асинхронно (нет порядка).
</li>
<li>FIFO (<i>first in first out</i>):

<p>
\(∄m,n ∈ M : snd(m) < snd(n) ∧ rcv(m) > rcv(n)\)
</p>

<p>
Алгоритмы FIFO используют нумерацию сообщений. Типа если надо
сделать FIFO, то заставим всех отправляющих нумеровать
сообщения, а всех принимающих смотреть на эти номерки и
шафлить, если вдруг пришло не по очереди.
</p>
</li>
<li>Причинно-согласованный порядок (<i>casually consistent order</i>).

<p>
\(∄m,n ∈ M : snd(m) → snd(n) ∧ rcv(n) → rcv(m)\)
</p>

<p>
Используется отношение "произошло до". Алгоритм для достижения
такого порядка основан на матричных часах. Пусть мы поток номер
\(i\). Заведем матрицу \(M[i,j]\), заполненную нулями. Перед
отправлением потоку \(j\) будем делать \(M[i,j] := M[i,j] + 1\). И
прикладывать новую матрицу. При получении матрицы \(W\) от \(P_j\),
будем считать что сообщение нам подходит, если:
</p>

<p>
\((W[i,j] = M[i,j] + 1) ∧ (∀k ≠ j : M[k,i] ≥ W[k,i])\)
</p>

<p>
В этом случае принимаем сообщение и делаем \(M := max(M,W)\).
</p>
</li>

<li>Синхронный порядок (<i>synchronous order</i>) &#x2013; всем событиям можно
сопоставить время \(T(m)\) так что время событий

<p>
\(T(rcv(m)) = T(snd(m)) = T(m)\) и \(∀e,f ∈ E: e → f ⇒ T(e) < T(f)\).
</p>

<p>
Алгоритм основан на иерархии процессов.
</p>
</li>

<li>Суммарно для unicast'а имеем: Synchronious \(⊂\) Casually ordered
\(⊂\) FIFO \(⊂\) Asynchronious
</li>
</ul>
</li>
<li>Multicast/broadcast &#x2013; общий порядок (<i>total order</i>). Только для
случаев когда одно сообщение идет многим получателям (\(rcv\) с
индексом процесса).

<p>
\(∄m,n ∈ M; p,q ∈ P: rcvₚ(m) < rcvₚ(n) ∨ rcv_q(n) < rcv_q(m)\)
</p>

<p>
Тривиально выполняется для всех unicast сообщений.
</p>

<p>
Алгоритмы общего порядка &#x2013; Лампорта и Скина.
</p>

<ul class="org-ul">
<li><b>Лампорт</b>. Модифицируем алгоритм взаимного исключения Лампорта,
предполагая FIFO-порядок. Сообщения транслируются всем
процессам. Каждый процесс содержит логические часы и очередь
отправленных сообщений.

<ol class="org-ol">
<li>Чтобы отправить сообщение, процесс говорит всем свое время
(похоже на запрос на вход в критическую секцию).
</li>
<li>При приеме сообщения оно сохраняется вместе со временем и
отправляется подтверждение, помеченное временем.
</li>
<li>Сообщение может быть доставлено процессу, если от всех
остальных потоков получены сообщения с большей временной
меткой (этот шаг аналогичен работе критической секции).
</li>
</ol>
</li>
<li><b>Скин</b>. Используются логические часы Лампорта.

<ol class="org-ol">
<li>Инициатор отправляет сообщение и время (мультикаст кому
надо).
</li>
<li>При приеме сообщения процесс помечает сообщение как
недоставленное, отправляет свое время инициатору.
</li>
<li>Когда инициатору вернулись все сообщения, он выбирает
макс. время и снова отправляет сообщение (финальное).
</li>
<li>При приеме финального сообщения оно помечается как
доставленное и доставляется получателю, если оно имеет
минимальное время в очереди сообщений.
</li>
</ol>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7"><span class="section-number-3">2.7</span> Системы, ошибки, FLP теорема</h3>
<div class="outline-text-3" id="text-2-7">
<p>
Иерархия ошибок в распределенных системах:
</p>
<ul class="org-ul">
<li>Отказ одного или нескольких узлов (<i>crash</i>)
</li>
<li>Отказ одного или нескольких каналов (<i>link failure</i>)
</li>
<li>Ненадежная доставка сообщений (<i>omission</i>) &#x2013; какие-то сообщения
могут не доставляться.
</li>
<li>Византийская ошибка (<i>byzantine failure</i>) &#x2013; самый сильный класс
ошибок, когда происходит что-то совершенно непредсказуемое с
сообщениями (перехват, изменение), любое поведение ноды.
</li>
</ul>

<p>
Системы делятся на синхронные и асинхронные:
</p>
<ol class="org-ol">
<li><b>Синхронные</b> &#x2013; время передачи ограничено сверху, можно разбить
выполнение алгоритма на фазы.
</li>
<li><b>Асинхронные</b> &#x2013; нету ограничения сверху на передачу сообщений, но
конечно, если система работает без ошибок.
</li>
</ol>

<p>
Свойства консенсуса в распределенной системе:
</p>
<ul class="org-ul">
<li><b>Согласие</b> (<i>agreement</i>) &#x2013; все (не сбойные) процессы должны
завершиться с одним и тем же решением.
</li>
<li><b>Нетрививальность</b> (<i>non-triviality</i>) &#x2013; должны быть варианты
исполнения приводящие к разным решениям.
</li>
<li><b>Завершение</b> (<i>termination</i>) &#x2013; протокол должен завершаться за
конечное время.
</li>
</ul>

<p>
Невозможность консенсуса в асинхронной системе с отказом узла (<i>FLP
&#x2013; Fischer Lynch Paterson</i>). Возможные предпосылки: асинхронность
системы, возможность отказа узла, а консенсус нужно достичь за
конечное время.
</p>

<ul class="org-ul">
<li><b>Теорема</b>: для \(N\) процессов достижение консенсуса невозможно (даже
на множестве значений \({0,1}\)).

<p>
Доказательство: от противного. Пусть такой алгоритм
существует. Покажем его несостоятельность.
</p>

<p>
<b>Процесс</b> &#x2013; это автомат, который может:
</p>
<ul class="org-ul">
<li><code>receive():msg</code> ожидать получения сообщения, причем нет
таймаутов по условию.
</li>
<li><code>send(msg)</code> отправлять сообщения.
</li>
<li><code>decided(value)</code> &#x2013; принимать решение. Можно делать решение
один раз, но терминирование программы после принятия решения не
обязательно (можно отправлять решение другим процессам).
</li>
</ul>
<p>
<b>Конфигурация</b> &#x2013; состояние всех процессов + сообщения в пути.
</p>

<p>
<b>Начальная конфигурация</b> &#x2013; содержит начальные данные для каждого
из процессов. Не обязательно один бит, а сколько угодно входных
данных. Каждый процесс может иметь свою программу.
</p>

<p>
<b>Шаг</b> между конфигурациями:
</p>
<ul class="org-ul">
<li>Обработка сообщения процессом (событие)
</li>
<li>Внутренние действия процесса между ожиданиями
сообщения. Детерменировано событием.
</li>
</ul>
<p>
<b>Исполнение</b> &#x2013; бесконечная цепочка шагов от начального состояния
(процессы не терминируются после принятия решения).
</p>

<p>
<b>Отказавший</b> процесс делает конечное число шагов в процессе
исполнения. Такой процесс единственен.
</p>

<p>
Любое сообщение для не отказавшего процесса обрабатывается через
конечное число шагов. Сообщения не теряются.
</p>

<p>
Все процессы, пришедшие к решению, имеют одно и то же решение \(∈
     {0,1}\). Один процесс имеет право упасть, но остальные должны
прийти к решению за конечное количество шагов.
</p>

<p>
Конфигурация называется:
</p>
<ul class="org-ul">
<li>$i$*-валентной*, если все цепочки шагов из нее приводят к
решению \(i ∈ {0,1}\).
</li>
<li><b>бивалентной</b> &#x2013; есть как цепочки шагов приводящие к решению
\(0\), так и к \(1\).
</li>
</ul>
<p>
Цепочки шагов с событиями на разных процессах коммутируют и
приводят к одной и той же конфигурации если поменять их порядок
выполнения.
</p>

<ul class="org-ul">
<li><b>Лемма 1</b>: существует начальная бивалентная конфигурация.

<p>
<i>Доказательство</i>:
</p>

<p>
От противного. Пусть нету, значит все конфигурации
одновалентны. Из нетривиальности следует существование и \(0\) и
\(1\)-валентных конфигураций. Найдем пару начальных конфигураций
разной валентности, отличающихся начальным состоянием только
одного процесса. Но этот процесс может отказать с самого
начала, тогда одна и та же цепочка шагов других процессов будет
возможна в обеих конфигурациях (упавший процесс не будет
совершать шагов &#x2013; упадет сразу).
</p>
</li>

<li><b>Лемма 2</b>: для бивалентной конфигурации можно найти следующую
за ней бивалентную.

<p>
Если \(G\) бивалентна и \(e\) &#x2013; какое-то событие (процесс \(p\),
сообщение \(m\)) в этой конфигурации, то возьмем:
</p>
<ul class="org-ul">
<li>\(C\) &#x2013; множество конфигураций достижимых из \(G\) без \(e\).
</li>
<li>\(D\) &#x2013; множество конфигураций \(D = e(C)\), то есть тех, где
\(e\) - последнее событие.
</li>
</ul>
<p>
Покажем, что \(D\) содержит бивалентную конфигурацию, тем самым
придем к противоречию с достижением консенсуса за конечное
число шагов <b>и этим докажем теорему</b>.
</p>

<p>
<i>Доказательство</i>:
</p>

<p>
Воспользуемся асинхронностью: нет предела на время обработки,
значит любое сообщение можно отложить на любое конечное время.
Будем доказывать лемму 2 от противного: пусть \(D\) не содержит
бивалентных конфигураций.
</p>

<ul class="org-ul">
<li><b>Лемма 2.1</b>: i-валентные конфигурации.

<p>
В \(D\) для любого \(i\) есть \(i\)-валентная конфигурация.
</p>

<p>
<i>Доказательство</i>:
</p>

<p>
Так как \(G\) бивалентна, то по какой-то цепочке шагов из нее
можно дойти до \(i\)-валентной \(Eᵢ\).
</p>
<ul class="org-ul">
<li>\(Eᵢ ∈ D\) &#x2013; мы нашли искомую конфигурацию.
</li>
<li>\(Eᵢ ∈ C\) &#x2013; \(e(C) ∈ D\) искомая конфигурация.
</li>
<li>Иначе \(e\) применялась в цепочке шагов для достижения \(Eᵢ ∈
           G\), а значит есть \(Fᵢ ∈ D\) сразу после применения \(e\), из
которой доступна \(Eᵢ\) по какой-то цепочке шагов. Мы
предположили, что в \(D\) нету бивалентных
конфигураций. Значит \(Fᵢ ∈ D\) \(i\)-валентна.
</li>
</ul>
</li>
<li><b>Лемма 2.2</b>: соседние конфигурации.

<p>
Найдем соседние (отличающиеся одним шагом \(e'\)) \(C₀ ∈ C\) и
\(C₁ ∈ C\), что \(D₀ = e(C₀) ∈ D\) является \(0\)-валентной, а \(D₁
         = e(C₁) ∈ D\) является \(1\)-валентной (например). Не теряя
общности, пусть \(C₀ = e'(C₁)\), где событие \(e'\) произошло на
процессе \(p'\).
</p>

<p>
Как найти: пусть, не теряя общности, \(e(G) ∈ D\) \(0\)-валентна
(если она \(1\)-валентна, то симметрично). Она соответствует
пустой цепочке шагов из \(G\).  По лемме 2.1 в \(D\) есть
\(1\)-валентная конфигурация \(D₁ = e(C₁) ∈ D\). Будем убирать из
цепочки шагов ведущей от \(G\) к \(C₁\) по одному шагу с конца,
пока не найдем искомую пару соседей \(C₀\) и \(C₁\).
</p>

<p>
Разбор случаев:
</p>
<ol class="org-ol">
<li>Если \(p ≠ p'\), то \(e\) и \(e'\) коммутируют. Получается, что
\(D₁\) должна быть одновременно \(1\)- и
\(2\)-валентной. Противоречие.
</li>
<li>Если \(p = p'\), то рассмотрим цепочку шагов \(σ\) от
состояния \(C₀\), где процесс \(p\) отказал (не выполняется),
а остальные пришли к решению. Тогда конфигурация \(A =
            σ(C₀)\), с решением, должна быть \(0\)- или \(1\)-валентной. Но
\(E₀ = e(A) = σ(D₀)\) \(0\)-валентная, а \(E₁ = e(e'(A)) =
            σ(D₁)\) \(1\)-валентная.
</li>
</ol>
</li>
</ul>
<p>
Итого теорема доказана.
</p>
</li>
</ul>
</li>
</ul>

<p>
Результат FLP о невозможности консенсуса верен даже если процессу
разрешено делать "атомарную передачу" сообщения сразу нескольким
процессам. Это следует из определения шага от конфигурации к
конфигурации. Однако, нет гарантии, что все процессы обработают
сообщение &#x2013; один может упасть и не получить.
</p>
</div>
</div>
<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8"><span class="section-number-3">2.8</span> Консенсус и TRB</h3>
<div class="outline-text-3" id="text-2-8">
<p>
Если есть гарантия получения сообщения всеми процессами (или ни
одним), то такая операция называется Terminating Reliable Broadcast
(<i>TRB</i>). С TRB можно тривиально написать алгоритм консенсуса. Но
суть в том, что сама по себе TRB сложна достаточно.
</p>

<p>
Применение консенсуса:
</p>
<ul class="org-ul">
<li>Выбор лидера &#x2013; каждый процесс предлагает себя, консенсус
определяет лидера для последующего распределенного алгоритма.
</li>
<li>TRB &#x2013; надо прийти к консенсусу о том, надо ли обрабатывать
полученное сообщение. Задача TRB эквивалентна задаче
консенсуса. То есть в асинхронной системе TRB тоже неразрешимa.
</li>
</ul>

<p>
Невозможность консенсуса при наличии ошибок (отказов) доказывается
только для детерменированных алгоритмов в асинхронной сети. Но
можно прийти к консенсусу, если:
</p>
<ul class="org-ul">
<li>Сделать сеть синхронной (ограничить время доставки сообщений)
</li>
<li>Сделать алгоритм недетерминированным (случайным)
</li>
<li>Ослабить требования наличия прогресса в алгоритме
</li>
</ul>

<p>
Алгоритмы консенсуса в синхронных сетях:
</p>

<p>
При отказе \(f\) узлов: делаем узел с \(f+1\) фазой.
</p>

<p>
Тупой алгоритм: пусть \(V\) &#x2013; набор значений, из которого мы
будем что-то предлагать. Сделам \(f+1\) итераций цикла, в которой
каждый узел отправит всем какое-то новое значение всем другим, а
также получит какие-то значения. Полученные значения положим в
\(V\). Так вот \(f+1\) итераций.
</p>

<p>
Согласимся выбрать \(min(V)\).
</p>


<p>
При византийской ошибке:
</p>
<ul class="org-ul">
<li>Решение возможно только при \(N > 3f\).
</li>
<li>2х-фазный алгоритм решения при \(N=4, f=1\). Обобщается на общий
алгоритм с \(f+1\) фазами.
</li>
<li>Доказательство невозможности при \(N=3, f=1\).
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-9" class="outline-3">
<h3 id="sec-2-9"><span class="section-number-3">2.9</span> Недетерминированные алгоритмы и Бен-Ор</h3>
<div class="outline-text-3" id="text-2-9">
<p>
Недетерминированные алгоритмы консенсуса:
</p>
<ul class="org-ul">
<li>Алгоритм рандомизирован.
</li>
<li>Достижение консенсуса требуется с вероятностью 1.
</li>
<li>Порядок исполнения операций в системе выбирает противник (либо
знающий все, либо как-то ограниченый, слабый).
</li>
<li>Алгоритм Бен-Ора для бинарного консенсуса работает даже при
сильном противнике при любом \(f < N/2\), но ожидаемое время
достижения консенсуса \(O(2^N)\).
</li>
</ul>

<p>
Алгоритм Бен-Ора (<i>Ben-Or</i>): есть множество раундов, по две фазы в
раунде. На каждой фазе процесс ждет получения \(N-f\) сообщений.
</p>
<ol class="org-ol">
<li>Фаза 1. <b>Предпочтение</b> рассылает текущее предпочтение посылая
всем сообщение \((1,k,p)\), где \(k\) &#x2013; номер раунда. Если больше
\(N/2\) голосов за одно значение, то <b>ратифицирует</b> его.
</li>
<li>Фаза 2: <b>Ратификация</b> шлет \((2,k,v)\), чтобы ратифицировать
значение или \((2,k,?)\), если не набрал нужное число
голосов.
<ul class="org-ul">
<li>Получив хотя бы одну ратификацию (свою или от другого) на
следующий раунд меняет предпочтение на полученное \(v\).
</li>
<li>Получив больше \(f\) ратификаций принимает решение \(v\),
продолжает исполняться.
</li>
<li>Не получив ратификации, меняет предпочтение для следующего
раунда на случайное.
</li>
</ul>
</li>
</ol>

<p>
Корректность Бен-Ора:
</p>
<ul class="org-ul">
<li><b>Лемма 1</b>: в одном раунде разные процессы не могут ратифицировать
разные значения. Очевидно из-за необходимости набрать больше
\(N/2\) сообщений \((1,k,v)\) для ратификации значения \(v\).
</li>
<li><b>Лемма 2</b>: если в раунде \(k\) процесс принял решение \(v\), то \(k+1\)
     раунд все процессы начнут с предпочтением \(v\).

<p>
Чтобы принять решение процесс получил минимум \(f+1\) сообщений
вида \((2,k,v)\). Чтобы начать раунд с другим предпочтением процесс
должен был получить \(N-f\) сообщений вида \((2,k,?)\). Сообщений с
другим \(v\) не может быть по лемме 1, а при приеме хотя бы одного
\((2,k,v)\) он бы взял предпочтение \(v\). Но \((f+1) + (N-f) > N\) &#x2013;
противоречие.
</p>
</li>
</ul>

<p>
Чтобы остановить алгоритм, а не исполнять его бесконечно, надо
выслать третий тип сообщения "<b>решение</b>" как только решение
принято, и при его получении принимать решение и останавливаться.
</p>

<p>
Система асинхронна. Сообщения не обязаны приходить в каждый процесс
раунд за раундом. Но так как на каждом раунде ждем \(N-f\) сообщений,
то фактически раунды получаются почти синхронными.
</p>

<p>
Даже если противник, который решает как приходят сообщения
(выбирающий цепочку шагов в исполнении), сильный (знает все
состояние системы), то вероятность завершения алгоритма за конечное
время все еще единица.
</p>
</div>
</div>
<div id="outline-container-sec-2-10" class="outline-3">
<h3 id="sec-2-10"><span class="section-number-3">2.10</span> Replicated State Machine, Paxos</h3>
<div class="outline-text-3" id="text-2-10">
<p>
Имеем некоторое состояние (счет в банке, персонаж в игре), надо
быстро его обновлять (не храним на диске) и хотим защитить его от
сбоев конкретного узла.
</p>

<p>
Решение &#x2013; хранить несколько копий этого состояния на разных узлах
для надежности. Если операции детерменировано влияют на состояние,
то можем независимо применять все операции к разным репликам. С
другой стороны, встает проблема поддержания единого состояния, если
операции не коммутируют. То есть, при одновременной попытке
выполнить несколько операций надо прийти к консенсусу, какая будет
первой.
</p>

<p>
Алгормти Paxos. Лампорт 1989. Первый алгоритм асинхронного
консенсуса.
</p>

<p>
Каждый проецсс выбирает одно значение из множества
предложенных. Гарантирует <b>согласие</b> при любых отказах и
произвольных задержках сообщений. Не гарантирует завершение за
конечное время (по теореме FLP не может гарантировать. Однако при
определенных практических реалиях консенсус достигается за конечное
число шагов).
</p>

<p>
Решим задачу однократного консенсуса &#x2013; выбора \(i\)-й операции над
RSM. Имеем множество <b>предлагающих</b> (<i>proposer</i>) процессов. Они
пытаются выполнить операцию над RSM и предлагают свою операцию в
качестве следующей. Проще всего, когда принимает решение один
<b>принимающий</b> (<i>acceptor</i>) процесс. Тогда нету проблемы прийти к
консенсусу (сообщение пришедшее к принимающему первым и принято),
но в случае отказа аксептора в системе не будет прогресса, поэтому
аксепторов должно быть много.
</p>

<p>
Нужна возможность узнать о принятом решении некому множеству
<b>узнающих</b> (<i>learner</i>) процессов. Принимающие процессы не обязаны
быть теми же самыми, которые хранят копию состояния RSM, они могут
только принимать решение о порядке операций, сообщая о нем
множеству узнающих процессов, которые обновляют у себя состояние
RSM.
</p>

<p>
Таким образом, в общем случае, имеем три роли. На практике они
могут произвольно совмещаться:
</p>
<ol class="org-ol">
<li>Предлагающие (<i>proposers</i>) предлагают значения.
</li>
<li>Принимающие (<i>acceptors</i>) принимают значения.
</li>
<li>Узнающие (<i>learners</i>) узнают о решениях.
</li>
</ol>

<p>
Хотим алгоритм, работающий корректно на основе кворума множества
принимающих значений. Множество принимающих процессоров и
используемый кворум заранее выбрано и зафиксировано. Кворум любой
&#x2013; большинство, например. Для кворума нужны не все
процессы. Предполагается, что отказы узлов временные. Отказ &#x2013;
уснул и не отвечает.
</p>

<p>
Среди принимающих выбираем <b>лидера</b>. Каждый предлагающий должен
знать множество принимающих и кто из них лидер. Лидер меняется,
если предыдущий отказал. Лидер выполняет вспомогательную функцию в
алгоритме. Мы не можем гарантироват выбор одного лидера за конечное
время (FLP и консенсус), но будем это делать все равно. Таким
образом, лидеров может быть несколько. Разные принимающие будут
иметь свое мнение о лидере, но алгоритм Paxos будет гарантировать
<b>согласие</b> и в этом случае, но без гарантий завершения пока лидеров
несколько.
</p>

<p>
Для прихода к консенсусу Paxos делает один или несколько раундов
<b>голосования</b>. Раунд инициализируется лидером (предложения
высылаются ему, а он их ставит на голосование). Несколько раундов
может случиться если нету согласия о едином лидере или что-то
отказало и надо голосовать заново. Вся структура алгоритма нужна
для обеспечения <b>согласия</b> несмотря на то, что несколько
голосований могут проходить одновременно. Каждое запущенное
голосование имеет уникальный номер \(k\) (можно взять пару из
процесса и локально увеличивающегося счетчика). Лидер может заново
инициировать голосование если видит что прогресса нету, с другим
\(k\).
</p>

<ol class="org-ol">
<li>1 фаза голосования:
<ol class="org-ol">
<li>1a (<b>подготовка</b>): лидер инициирует голосование и посылает
сообщение \((1a, k)\) кворуму принимающих, где \(k\) это
глобальный уникальный номер голосования.
</li>
<li>1т (<b>обещание</b>): получив \((1a, k)\) принимающий обещает не
принимать предложение с меньшим номером и отвечает \((1b, k,
         ack, k', v')\), где \((k', v')\) это иноформация о <b>принятом</b>
предложении с максимальным номером \(k' < k\) (см. фазу 2b),
где \(k' = 0\), если ничего еще не принято. Или сообщает, что
уже дал другое обещание для \(k'' > k\) и отвечает \((1b, k'',
         nack)\), на что лидер повторит \(1a\) заново, послав \((1a,
         k'')\).
</li>
</ol>
</li>
<li>2 фаза голосования:
<ol class="org-ol">
<li>2a (<b>запрос</b>): лидер, получив обещания \((1b, k, ack, k', v')\)
от кворума принимающих, предлагает свое значение. Берет
значение \(v'\) для наибольшего \(k'\) полученного от
аксептеров. А если все \(k' == 0\), то предлагает свое значение
\(v\) и посылает запрос \((2a, k, v)\) кворуму принимающих. На
второй фазе можно использовать другой кворум.
</li>
<li>2b (<b>подтверждение</b>): если принимающий получает запрос \((2a,
         k, v)\) и он не давал обещание для \(k' > k\), то он <b>принимает</b>
предложение \((k,v)\) и посылает \((2b, k, v)\) всем
узнающим. Узнающий, получив сообщение \((2b, k, v)\) от кворума
принимающих, узнает о том, что выбрано \(v\).
</li>
</ol>
</li>
</ol>

<p>
Модификации Paxos:
</p>
<ul class="org-ul">
<li>Multi paxos &#x2013; выполняя paxos много раз подряд, можно делать
фазу 1 для всех копий сразу (она не зависит от \(v\)) и,
подтвердив факт наличия уникального лидера через это, делать для
каждой копии алгоритма Paxos свою фазу 2. Получаем задержку в 3
сообщения между proposer-ом и learner-ом.
</li>
<li>Fast paxos &#x2013; посылаем предложения acceptor-ам в обход
лидера. Задержка в 2 сообщения между proposer-ом и learner-ом
если нет коллизий.
</li>
<li>Dynamic paxos &#x2013; меняем набор серверов во время работы
</li>
<li>Cheap paxos &#x2013; активно используем только кворум из \(f+1\)
     сервером и только при отказе подключаем \(f\) запасных.
</li>
<li>Stoppable paxos, byzantine paxos, &#x2026;
</li>
</ul>

<p>
Транзакции в распределнных системах. <b>Транзакция</b> &#x2013; единица работы
над множеством элементов, хранящихся в БД. <b>ACID</b> &#x2013; atomicity,
consistency, isolation, durability. Транзакции деляться на 2PL (2
phase locking) и 2PC (2 phase commit).
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2016-02-15</p>
<p class="date">Created: 2016-06-21 Tue 10:41</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.2 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
