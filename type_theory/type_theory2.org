#+TODO: X 0 1 2 | OK
#+TITLE: Tеория типов, часть вторая.

* Martin-Lof type system
** Источники
   Martin-Lof’s Type Theory
   B. Nordstrom, K. Petersson and J. M. Smith

   http://www.cse.chalmers.se/~bengt/papers/hlcs.pdf
** Вступление
   Напомним всем, чем отличается конструктивный интуиционизм от
   классического подхода. Наглядная иллюстрация: конструктивное
   доказательство очень близко к компьютерной программе. Пусть нужно
   доказать:
   (∀x∈A)(∃y∈B)P(x,y)                                        (1)
   С конструктивной точки зрения, вывод такого утверждения значит
   показать функцию f, такую что f:A → B, и она дает ровно нужный y для
   того чтобы удовлетворить P(x, y). Тогда если (1) выражает некоторую
   спецификацию, то конкретная f -- это программа, удовлетворяющая этой
   спецификации. Отсюда конструктивное доказательство может
   рассматриваться как программа, а процесс вычисления значения --
   нормализация доказательства.

   # Забавные (?) факты.
   Был такой ученый, значит, Brouwer Luitzen Egbertus Jan (Брауер
   Лёйтзен Эгберт Ян, фамилия -- первое) (1881-1966), голлндский
   математик. Ему удалось в некоторый момент показать, что в
   некоторых случаях невычислимость функций классической математики
   исходит не от аксиомы выбора, как тогда было принято считать, а от
   таких вещей, как правило исключенного третьего, доказательство от
   противного и закон снятия двойного отрицания. Брауера называют
   основоположником интуиционизма, хотя идею в основном развил
   Гейтинг, его ученик (Гейтинг сформулировал интуиционистскую логику
   в 1930).

   # Рассказать что-то про интенсиональность и экстенциональность
   # теории типов.

   Теория, которая описана здесь, была предложена Мартином-Лёфом в
   1986 году.
** Утверждения как множества
#   Первоначально идея воспринимать утверждения как множества была
#   выдвинута Карри, впоследствии того, что было замечено сходство
#   аксиом импликативного фрагмента интуиционистской логики первого
#   порядка:
#   A ⊃ B ⊃ A
#   (A ⊃ B ⊃ C) ⊃ (A ⊃ B) ⊃ A ⊃ C
#   С типами базовых комбинаторов K и S:
#   K ∈ A → B → A
#   S ∈ (A → B → C) → (A → B) → A → C
#   Тогда MP соответствует применению функций (комбинаторов).
   Утверждения можно сопоставлять множествам. Это можно увидеть,
   рассмотрев объяснения Гейтинга в терминах доказательств.
   Для импликации верно:
   Доказательство A ⊃ B -- функция, которая по каждому доказательству
   A выдает доказательство B.
   Нотация функции или метода тут примитивна в конструктивной
   математике, и функцию из A в B можно рассматривать как программу,
   которая, когда применена к элементу из A, выдает элемент B как
   выходной параметр. Давайте тогда сопоставим утверждение с набором
   его доказательств:
   * A ⊃ B сопоставимо с A → B, множество функций из A в B.
   Элементы из A → B имеют форму λx.b, где b ∈ B, и b зависит от x∈A.

   Гейтинг обяъсняет конъюнкцию как пару из двух доказательств. Тогда
   сопоставление с множеством очевидно:
   * A ∧ B сопоставимо с A × B, прямое произведение A и B.

   Для дизъюнкции -- она верна, если у нас есть доказательство одного
   из двух утверждений, причем с конкретным указанием, какого. Отсюда:
   * A ∨ B сопоставимо с A + B.
   Элементы A + B имеют форму inl(a) или inr(b), где a∈A, b∈B.

   ¬A ≡ A ⊃ ⊥.
   С таким определением, где ⊥ -- противоречие, утвеждение без
   доказательства, сопоставление таково:
   * ¬A сопоставимо с A → ∅.

   Чтобы отождествить утверждения с кванторами, нам нужны операции на
   наборах множеств. Пусть B[x ← a] -- выражение, полученное
   подстановкой a для всех свободных вхождений x в B. Тогда Гейтингово
   объяснение таково:
   Доказательство (∃x ∈ A)B состоит из построения элемента a множества A
   вместе с доказательством B[x ← a].
   Таким образом, доказательство -- пара. Сопоставимое с парой
   множество -- это непересекающееся объединение множеств,
   обозначающееся (∑x ∈ A)B. Элементы -- пары <a,b>, где a∈A, b∈B[x ← a].
   Тогда формальное сопоставление таково:
   * (∃x ∈ A)B сопоставляется с множеством (∑x ∈ A)B.

   И, наконец, квантор всеобщности:
   Доказательство (∀x ∈ A)B -- функция (метод/программа), которая
   каждому элементу a из множества A сопоставляет доказательство
   B[x ← a].
   Множество, которое соответствует квантору всеобщности -- прямое
   произведение семейства множеств, обозначается (Πx ∈ A)B. Элементы
   этого множества -- функции, которые, в применении к элементу a ∈ A
   возвращают элемент B[x ← a]. Отсюда, формально:
   * (∀x ∈ A)B сопоставляется с множеством (Πx ∈ A)B.
   Элементы (Πx ∈ A)B находятся в форме λx.b, где b ∈ B, причем как b
   так и B зависят от x ∈ A. Отметим, что если B не зависит от x, то
   (Πx ∈ A)B есть то же самое, что и A → B, отсюда можно обойтись без
   →, если есть прямое произведение семейства множеств. В этом же
   смысле, (∑x ∈ A)B есть ничто иное, как A × B, когда B не зависит от
   x.

   Все эти нотации -- сахар, который будет раскрыт позже.
** Типы, их равенство, равенство объектов
   Базовая нотация в MLTT -- нотация типа. Объясним, что такое тип, и
   что значит для двух типов быть идентичными. Мы проводим суждение
   A -- тип, и формально записываем это как "A type", когда знаем
   условия для того, чтобы утверждать "некий объект имеет тип A" и
   когда знаем условия для того, чтобы утверждать, что два объекта типа A
   идентичны. Последнее условие должно определять отношение
   эквивалентности.
   Первое есть удовлетворение следующего условия:
   a -- объект типа A.
   Что формально записывается:
   a ∈ A.
   Второе -- удовлетворение такого условия:
   a и b -- идентичные объекты типа A.
   Что формально записывается
   a = b ∈ A

   A -- тип, если знаем условия для того, чтобы утверждать:
   1. a ∈ A
   2. a = b ∈ A

   Равенство на типах выполняется, когда объект одного типа является
   объектом и другого типа и когда два идентичных объекта одного типа
   являются идентичными для другого.
   A и B идентичны.
   A = B.
   Равенство на объектах симметрично, рефлексивно и транзитивно.
   * a ∈ A                ⇒⇒ a = a ∈ A
   * a = b ∈ A            ⇒⇒ b = a ∈ A
   * a = b ∈ A, b = c ∈ A ⇒⇒ a = c ∈ A
   Равенство на типах тоже есть отношение эквивалентности.
   * A type       ⇒⇒ A = A
   * A = B        ⇒⇒ B = A
   * A = B, B = C ⇒⇒ A = C
   Кроме того, равенство на типах:
   * a ∈ A, A = B     ⇒⇒ a ∈ B
   * a = b ∈ A, A = B ⇒⇒ a = b ∈ B
** Гипотетические суждения, контекст
   Гипотетическое суждение -- суждение, сделанное в контексте:
   x₁ ∈ A₁, x₂ ∈ A₂, ... xₙ ∈ Aₙ
   Где A₁ тип, A₂ тип в контексте x₁ ∈ A₁, ... Aₙ тип в контексте
   всех перед ним.

   Пусть C -- тип, не зависящий ни от каких посылок. Тогда A -- тип,
   когда x ∈ C:
   A type [x ∈ C]
   То есть для любого c ∈ C A[x ← c] есть тип.
   Тогда A будет называться семеством типов над (over) C.

   * A = B [x ∈ C] значит, что A[x ← c], B[x ← c] одинаковые типы для
     любого c ∈ C.
   * a ∈ A [x ∈ C] значит, что a -- объект типа A при x ∈ C, то есть
     мы уже знаем, что a[x ← c] есть объект типа A[x ← c] для любого
     c ∈ C.

   Пусть x₁∈A, x₂∈A₂,...xₙ∈Aₙ -- контекст длины n-1.
   Тогда верно:
   A₁ type
   A₁ type [x₁ ∈ A₁]
   ...
   Aₙ type [x₁ ∈ A₁, x₂ ∈ A₂, ... x{n-1} ∈ A{n-1}]

   Допустим мы хотим знать
   A type [x₁ ∈ A₁, ... xₙ ∈ Aₙ]
   Это значит (формально), что мы хотим знать следующее:
   A[x₁ ← a] type [x₂ ∈ A₂ [x₁ ← a],... xₙ ∈ Aₙ [xₙ ← a]]
   Причем такое утврерждение должно быть верно в пустом контексте.
   Тогда если к томе же a = b ∈ A, также верно:
   A[x₁ ← a] = A[x₁ ← b] [x₂ ∈ A₂ [x₁ ← a],... xₙ ∈ Aₙ [xₙ ← a]]
   Формально это выражается так:
   * A type [x₁ ∈ A₁...xₙ ∈ Aₙ], a ∈ A₁     ⇒⇒
     A[x₁ ← a] type [x₂ ∈ A₂[x₁ ← a],.. xₙ ∈ Aₙ[x₁ ← a]]
   * A type [x₁ ∈ A₁...xₙ ∈ Aₙ], a = b ∈ A₁ ⇒⇒
     A[x₁ ← a] = A[x₁ ← b] [x₂ ∈ A₂[x₁ ← a],.. xₙ ∈ Aₙ[x₁ ← a]]

   Подстановка в равных типах:
   Пусть A, B -- типы в контексте [x₁ ∈ A₁...xₙ ∈ Aₙ].
   * A = B [x₁ ∈ A₁...xₙ ∈ Aₙ], a ∈ A₁ ⇒⇒
     A[x₁ ← a] = B[x₁ ← a] [x₂ ∈ A₂[xᵢ ← a],...xₙ ∈ Aₙ[xᵢ ← a]]

   Подстановка в объектах:
   Пусть A -- тип в контексте [x₁ ∈ A₁...xₙ ∈ Aₙ].
   * a ∈ A [x₁ ∈ A₁...xₙ ∈ Aₙ], a ∈ A₁ ⇒⇒
     a[x₁ ← a] ∈ A[x₁ ← a] [x₂ ∈ A₂[xᵢ ← a],...xₙ ∈ Aₙ[xᵢ ← a]]

   Подстановка в равных объектах:
   Пусть c = d ∈ A -- тип в контексте [x₁ ∈ A₁...xₙ ∈ Aₙ].
   * c = d ∈ A [x₁ ∈ A₁...xₙ ∈ Aₙ], a ∈ A₁ ⇒⇒
     c[x₁ ← a] = d[x₁ ← a] ∈ A[x₁ ← a]
                            [x₂ ∈ A₂[xᵢ ← a],...xₙ ∈ Aₙ[xᵢ ← a]]

   Предположение:
   A₁ type
   A₂ type [x₁ ∈ A₁]
   ...
   Aₙ type [x₁ ∈ A₁ ... до n-1]
   A type [x₁ ∈ A₁ ... xₙ ∈ Aₙ]
   ⇒⇒
   x ∈ A[x₁ ∈ A₁...xₙ ∈ Aₙ, x ∈ A]

** Типы-функции
   Пусть A -- тип, B -- семейство типов над A, тогда (x ∈ A)B -- тип
   функции.

   Быть объектом c типа (x ∈ A)B значит знать:
   1. Когда мы применяем c к a типа A, то получаем c(a)
      в B[x ← a].
   2. Мы получаем одинаковые объекты в B[x ← a], когда применяем к c
      a = b ∈ A.

   * c = d ∈ (x ∈ A)B значит, что для любого a ∈ A c(a) и b(a) есть
     одинаковые элементы типа B[x ← a].

   Функциональный тип.
   * A type, B type [x ∈ A] ⇒⇒ (x ∈ A)B type
   Тип равенства функций.
   * A = A', B = B' [x ∈ A] ⇒⇒ (x ∈ A)B = (x ∈ A')B'

   Синтаксический сахар:
   * (A)B есть (x∈A)B, когда B не зависит от x.
   * (x ∈ A; y ∈ B)C есть (x ∈ A)(y ∈ B)C
   * (x,y ∈ A)B есть (x ∈ A; y ∈ A)C
   * c(a₁,a₂,...aₙ) есть c(a₁)(a₂)...(aₙ)

   Правила для аппликации:
   * c ∈ (x ∈ A)B, a ∈ A     ⇒⇒ c(a) ∈ B[x ← a]
   * c ∈ (x ∈ A)B, a = b ∈ A ⇒⇒ c(a) = c(b) ∈ B[x ← a]

   Правила, показывающие равенство функций:
   Аппликация (тут переходим от функций к применению):
   * c = d ∈ (x ∈ A)B, a ∈ A ⇒⇒ c(a) = d(a) ∈ B[x ← a]
   Экзистенциональность (тут переходим от применений к чистым):
   * c ∈ (x ∈ A)B, d ∈ (x ∈ A)B, c(x) = d(x) ∈ B[x ∈ A] ⇒⇒
     c = d ∈ (x ∈ A)B,
     тут x не входит свободно ни в c ни в d.

   Абстракция:
   * b ∈ B[x ∈ A] ⇒⇒ ([x]b) ∈ (x ∈ A)B
   Сахар:
   * [x₁,...xₙ]b = [x₁][x₂]..[xₙ]b
   β-конверсия:
   * a ∈ A, b ∈ B[x ∈ A] ⇒⇒ ([x]b)(a) = b[x ← a] ∈ B[x ← a]

   Два доказываемых правила:
   # Заставить кого-нибудь доказать
   η-конверсия:
   * c ∈ (x ∈ A)B ⇒⇒ ([x]c)(x) = c ∈ (x ∈ A)B, x не свободно в c
     Какой-то очевидный переход (лол)
     c ∈ (x ∈ A)B ⇒⇒ x ∈ A, c ∈ B[x ∈ A]
     β-конверсия:
     x ∈ A, c ∈ B[x ∈ A] ⇒⇒ ([x]c)(x) = c[x ← x] ∈ B[x ← c]
   ξ-правило
   * b = d ∈ B[x ∈ A] ⇒⇒ [x]b = [x]d ∈ (x ∈ A)B
** Тип Set
   Set -- тип, в котором есть объекты.
   Сразу сахар: A -- сет (set) значит, что A является элементом
   (объектом) в Set.
   1. Чтобы знать, что A -- сет необходимо знать, как определять
      канонические элементы A и когда они одинаковы.
      Канонический элемент -- это элемент в форме некоторого
      конструктора, вроде zero или succ.
   2. Два сета одинаковые (два элемента одинаковы и являются объектами
      в Set), если элемент одного сета есть элементом и другого сета, и
      если два элемента равны и принадлежат первому сету, то и
      второму.

   Формально:
   * Set type
   * A ∈ Set ⇒⇒ El(A) type
   # В оригинале так: A : Set ⇒⇒ El(A) type, что бы это ни значило.

   El -- некий оператор, отображающий элементы Set (сеты) в
   соответствующие им типы (поскольку, формально, элементы Set есть не
   типы, а объекты). На практике не пишется нигде, потому что и так
   понятно (так считают авторы повсеместно).
** Определения, константы
   Мы умеем делать всякие константы! Давайте различать примитивные и
   определяемые константы. Значение примитивной константы есть сама
   константа. Константа имеет только тип, не определение. Значение она
   получает из семантики теории.
   Примеры примитивных констант: ℕ, succ, 0.
     N    ∈ Set
     succ ∈ N → N
     0    ∈ N

   Определяемые константы определяются в терминах других объектов. Они
   бывают эксплицитно или имплицитно определенными.
   Эксплицитно определенная константа -- такое c, что:
     c = a ∈ A
   Примеры эксплицитно определенных констант:
     1  = succ(0) ∈ N
     In = [x]x ∈ N → N
     # Напоминание: (B)A -- сахар для: (x ∈ B)A, A не зависит от x
     I  = [A,x]x ∈ (A ∈ Set; A)A
   Имплицитно определенная константа -- это предоставление некоротых
   определяющих слов которые она имеет, когда мы применяем ее к
   аргументам.
   Пользуемся паттерн-матчингом и рекурсией. Примеры:
     +            ∈ ℕ → ℕ → ℕ
     +(0,y)       = y
     +(succ(x),y) = succ( +(x,y))
   Вот примитивная рекурсия:
     natrec                 ∈ ℕ → (ℕ → ℕ → ℕ) → ℕ → ℕ
     natrec (d, e, 0)       = d
     natrec (d, e, succ(a)) = e(a, natrec(d, e, a))
** Пропозициональная логика
   Теория -- набор типизаций:
     c₁ ∈ A₁ ... cₙ ∈ Aₙ
   Где c₁...cₙ -- новые примитивные константы. И еще список определений
   из определяемых констант:
     d₁ = e₁ ∈ B₁ ... dₘ = eₘ ∈ Aₘ

   Базовые типы в MLTT -- Set и все типы элементов в конкретных сетах,
   которые мы представим позже.
   Давайте определим всякие множественные связки:

*** Конъюнкция
    Введем примитивную константу:
    * & ∈ (Set; Set)Set
    &-formation:
    * A ∈ Set, B ∈ Set ⇒⇒ A&B ∈ Set
    Доказательством конъюнкции будет следующяя примитивная константа:
    * &I ∈ (A,B ∈ Set; A; B) A&B
    Это объявление -- индуктивное определение сета &(A,B), такое что
    все элементы сета &(A,B) равны элементу в форме &I(A,B,a,b),
    где A и B -- сеты и a ∈ A, b ∈ B.
    Доказательство в такой синтаксической форме называется каноническим.

    По правилу функциональной аппликации (применному 4 раза), получаем:
    # Оно, кстати, выглядит так:
    # c ∈ (x ∈ A)B, a ∈ B  ⇒⇒ c(a) ∈ B[x ← a]
    &-introduction:
    * A ∈ Set, B ∈ Set, a ∈ A, b ∈ A ⇒⇒ &I(A,B,a,b) ∈ A&B
      Доказательство:
      &I ∈ (A ∈ Set)(B ∈ Set; A; B)A&B,  A ∈ Set ⇒⇒
      &I(A) ∈ (B ∈ Set; A; B)A&B      ,  B ∈ Set ⇒⇒
      &I(A,B) ∈ (A; B)A&B             ,  a ∈ A   ⇒⇒
      &I(A,B,a) ∈ (B)A&B              ,  b ∈ B   ⇒⇒
      &I(A,B,a,b) ∈ A&B

    Чтобы получить два правила, раскрывающих конъюнкцию, введем две
    определенные константы с помощью равенств:
    # Напоминаем, что синтаксис работает в виде (a = b) ∈ C
    * &E1(A,B,&I(A,B,a,b)) = a ∈ A
    * &E2(A,B,&I(A,B,a,b)) = b ∈ B

    Проверим, что типизации констант корректны.
    * Если A ∈ Set, B ∈ Set, p ∈ A&B, то &E1(A,B,p) ∈ A.
      p ∈ A&B, тогда p равно элементу формы &I(A,B,a,b), где a ∈ A,
      b ∈ B -- это свойство канонического доказательства.
      Тогда:
      &E1(A,B,p) = &E1(A,B,&I(A,B,a,b)) = {раскрыли по опр &E1} = a ∈ A.
    * Второе аналогично

    Из последнего семантического доказательства типизаций получаем
    формальные правила:
    &-elimination 1 and 2:
    * A ∈ Set, B ∈ Set, c ∈ A & B ⇒⇒ &E1(A,B,c) ∈ A
    * A ∈ Set, B ∈ Set, c ∈ A & B ⇒⇒ &E2(A,B,c) ∈ B
*** Импликация
    Примитивная константа ⊃ вводится декларацией:
    * ⊃ ∈ (Set;Set)Set
    ⊃-formation (доказывается применением функциональной аппликации):
    * A ∈ Set, B ∈ Set ⇒ A ⊃ B ∈ Set
    Каноническое доказательство:
    * ⊃I ∈ (A, B ∈ Set, (A)B)A ⊃ B
    ⊃-introduction (доказывается):
    * A ∈ Set, B ∈ Set, b(x) ∈ B[x ∈ A] ⇒⇒ ⊃I(A,B,b) ∈ A ⊃ B
      Доказательство
      ⊃I ∈ (A ∈ Set)(B ∈ Set; (A)B)A ⊃ B, A ∈ Set      ⇒⇒
      ⊃I(A) ∈ (B ∈ Set; (A)B)A ⊃ B,       B ∈ Set      ⇒⇒
      Тут нужно дополнительно привести b(x) к виду b, это можно
      сделать с помощью правила абстракции (наверное).
      ⊃I(A,B) ∈ ((A)B)A ⊃ B,              b ∈ (x ∈ A)B ⇒⇒
      ⊃I(A,B,b) ∈ A ⊃ B
    Как и в конъюнкции, introduction помогает из трех элементов
    получить каноническое доказательство связки.

    Чтобы получить Modus Ponens, то есть ⊃-elimination, нам нужна
    определенная константа, заданная с помощью равенства:
    * ⊃E(A,B,⊃I(A,B,b,a)) = b(a) ∈ B
    Имеющая тип:
    * ⊃E ∈ (A,B ∈ Set; A ⊃ B; A)B
    ⊃-elimination aka Modus Ponens (из функциональной аппликации и
    типизации ⊃E):
    * A ∈ Set, B ∈ Set, b ∈ A ⊃ B, a ∈ A ⇒⇒ ⊃E(A,B,b,a) ∈ B
      Доказательство:
      ⊃E ∈ (A,B ∈ Set; A ⊃ B; A)B,  A ∈ Set   ⇒⇒
      ⊃E(A) ∈ (B ∈ Set; A ⊃ B; A)B, B ∈ Set   ⇒⇒
      ⊃E(A,B) ∈ (A ⊃ B; A)B,        b ∈ A ⊃ B ⇒⇒
      ⊃E(A,B,b) ∈ (A)B,             a ∈ A     ⇒⇒
      ⊃E(A,B,b,a) ∈ B
** Теория сетов
   Вкратце.
   Давайте определять сеты с натуральными числами, листами, функциями
   и прочим.

   Как определить новый сет:
   1. Ввести примитивную константу для сета.
   2. Ввести примитивные константы для конструкторов.
   3. Вывести formation rule -- типизационное правило для
      константы, обозначающей сет.
   4. Вывести introduction rules -- типизационные правила для
      конструкторов.
   5. Определить селектор -- имплицитно определенную константу (то
      есть можно рекурсию, паттерн-матчинг), выражающую сущность,
      индуктивный принцип сета.
      Equality rules -- равенства, задающие селектор(ы).
   6. Вывести elimination rules для селектора.

   Поехали.
*** Boolean set
    1. Bool ∈ Set
    2. true ∈ Bool
       false ∈ Bool
    3. formation rule не нужен, так как Bool атомарен.
    4. introduction rule не нужен, так как конструкторы не сложные.
    5. Селектор (equality rules):
       if(C,true,a,b)  = a
       if(C,false,a,b) = b

       В equality rules опущены типы в силу очевидности.
       Сахар: a = b пишется вместо a = b ∈ A когда A очевидно.

       Должно быть понятно, какой тип у if:
       if ∈ (C ∈ (Bool)Set; b ∈ Bool; C(true); C(false))C(b)
    6. elimination rules выводятся из функциональной аппликации
       elimination-2 (1 -- аналогично):
       * C ∈ (Bool)Set, c ∈ C(true), d ∈ C(false) ⇒⇒
         if(C, false, c, d) ∈ C(false)
         Доказательство:
         if ∈ (C ∈ (Bool)Set; b ∈ Bool; C(true); C(false))C(b); C ∈
         (Bool)Set ⇒⇒
         if(C) ∈ (b ∈ Bool; C(true); C(false))C(b), false ∈ Bool ⇒⇒
         if(C, false) ∈ (C(true); C(false))C(false), c ∈ C(true) ⇒⇒
         if(C, false, c) ∈ (C(false))C(false),      d ∈ C(false) ⇒⇒
         if(C, false, c, d) ∈ C(false)
*** Empty set
    1. {} ∈ Set
    2. Конструкторов нет
    3. ∅
    4. ∅
    5. case ∈ (C ∈ ({})Set; a ∈ {})C(a)
       Соответствует утверждению абсурдности
       ⊥ true, C prop ⇒⇒ C true
    6. ∅
*** Natural numbers
    1. ℕ ∈ Set
    2. 0 ∈ ℕ
       succ ∈ (n ∈ ℕ)ℕ
    3. Не нужен
    4. Можно вывести succ-introduction rule:
       a ∈ ℕ ⇒⇒ succ(a) ∈ ℕ
       Доказательство очевидно через аппликацию.
    5. natrec ∈ (C ∈ (ℕ)Set;
                 d ∈ C(0);
                 e ∈ (x ∈ ℕ, y ∈ C(x))C(succ(x));
                 n ∈ ℕ) C(n)

       natrec(C,d,e,0) = d
       natrec(C,d,e,succ(m)) = e(n,natrec(C,d,e,m))

       Ввести еще можно plus,mult:
       plus ∈ (ℕ,ℕ)ℕ
       mult ∈ (ℕ,ℕ)ℕ
       plus(m,n) = natrec([x]ℕ, n, [x,y]succ(y), m)
       mult(m,n) = natrec([x]ℕ, 0, [x,y]plus(y,n), m)
    6. Выводится
*** Cartesian product of a family of sets (Π)
    (x ∈ A)B -- это тип. Мы хотим коррелирующий сет. Пусть есть сет A
    и семейство сетов B над A (A -- сет, для каждого a ∈ A существует
    B(a) -- тоже сет), тогда Π(A,B) -- прямое произведение A и B.
    Π(A,B) хранит в себе функции, которые отображают элементы a ∈ A в
    какие-то элементы z ∈ B(a).
    1. Π ∈ (A ∈ Set; B ∈ (x ∈ A)Set) Set
    2. λ ∈ (A ∈ Set; B ∈ (x ∈ A)Set; f ∈ (x ∈ A)B) Π(A,B)
       Тут f отображает из элемента x в сет, являющийся
       подсемейством B.

       Тут я придумал пример!
       λ(ℕ, [x](if x > 1 then ℕ else Bool), foo) ∈ Π(ℕ, {ℕ, Bool})
       где foo(0) = false
           foo(1) = true
           foo(n) = n - 2
    3. A ∈ Set, B(x) ∈ Set[x ∈ A] ⇒⇒ Π(A,B) ∈ Set
    4. A ∈ Set, B(x) ∈ Set[x ∈ A], f ∈ B(x)[x ∈ A] ⇒⇒
       λ(A,B,f) ∈ Π(A,B)
       Заметим, что эти "функции" гораздо более общие, чем обычные --
       Π(A,B) -- прямое произведение семейств сетов.
    5. apply ∈ (A ∈ Set; B ∈ (x ∈ A)Set; g ∈ Π(A,B); a ∈ A)B(a)
       apply(A,B,λ(A,B,f),a) = f(a)

       Заметим также, что в отождествлении с выражениями, Π(A,B)
       соответствует (∀x ∈ A)B(x).

       Пусть семейство функций B над A никак не меняется в зависимости
       от элементов x ∈ A. Тогда прямое произведение -- сет функций.
       → ∈ (A,B ∈ Set)Set
       → = [A,B]Π(A, [x]B)

       ¬ ∈ (A ∈ Set)Set
       ¬(A) = A → {}
**** Бонус
     Давайте докажем A ⊃ ¬¬A.
     Что эквивалентно следующей задаче:
     Найдем хоть какой-нибудь элемент в сете:
     A → (¬(¬A)) ≡ A → ((A → {}) → {})

     !!!
     Хинт: мы пользуемся тут λ для →, упрощенной версией.
     такой:
     λ' ∈ (A, B ∈ Set; f ∈ (x ∈ A)B)(A → B)
     Это работает, потому что:
     A ∈ Set, B ∈ Set.
     λ(A, [x]B, [x]f([x]B(x))) ∈ Π(A, [x]B)
     λ(A, [x]B, [x]f([x]B(x))) ∈ A → B

     Аналогично для apply:
     apply' ∈ (A, B ∈ Set; g ∈ A → B, a ∈ A) B(a)
     Потому что:
     A, B ∈ Set,
     apply(A, [x]B, λ'(A, B, f), a) = f(a) ∈ B(a)

     Пусть верно:
     A → ¬¬A
     Давайте докажем A → ((A → {}) → {}).
     Для этого нужно доказать:
     λ'(A, ((A → {}) → {}), foo).
     При этом хотим foo ∈ (x ∈ A)((A → {}) → {}).
     Пусть foo выглядит как [x]bar, тогда bar имеет стрелочный тип,
     отсюда:
     foo := [x]λ'(A → {}, {}, foo2).
     Ага, ну то есть foo2 должна быть типа (y ∈ A → {})({}).
     Опять-таки, представим foo2 как [y]bar2.

     Что имеем (последовательно):
     λ'(A, (A → {}) → {}, [x]bar),
     bar ∈ (A → {}) → {}
     λ'(A, (A → {}) → {}, [x](λ'(A → {}, {}, [y]bar2)),
     bar2 ∈ {}
     bar2 = apply'(A, {}, y, x) (это тут мы применяем y ∈ A → {} к
     x ∈ A, то есть получаем элемент z ∈ {})

     Вот вам корректно типизируемое выражение нужного типа:
     Ans ≡ λ'(A, (A → {}) → {},
              [x](λ'(A → {}, {},
                  [y](apply(A, {}, y, x))))
     Тогда, выходит, Ans ∈ A → ((A → {}) → {}) = A → ¬¬A.
     Мы нашли элемент в типе, чего и хотели.
*** Identity set
    a = b ∈ A -- это равенство определяемое, два объекта равны, когда
    имеют одинаковую нормальную форму.
    Мы хотим же, например, выразить тот факт, что сложение натуральных
    чисел -- коммутативная операция. Для этого нам потребуется:
    * Id ∈ (X ∈ Set; a ∈ X; b ∈ X) Set
      В этом сете лежат доказательства того, что элементы a и b равны
      (достаточно семантическое объяснение).
    * id ∈ (X ∈ Set; x ∈ X) Id(X, x, x)
      id -- единственный конструктор для Id(A, a, b), то есть
      Id(A, a, b) наименьшее рефлексивное отношение на
      A. Транзитивность, симметричность могут быть доказаны.
    * idpeel ∈ (A ∈ Set;
                C ∈ (x,y ∈ A; e ∈ Id(A, x, y)) Set;
                a, b ∈ A;
                e ∈ Id(A, a, b);
                d ∈ (x ∈ A)C(x, x, id(A, x))) C(a, b, e)
      idpeel(A, C, a, b, id(A, a), d) = d(a)
      О константе можно думать как о подстановке для равных элементов
      -- если у нас есть общий тип a, b, тип, куда мы будем мапать
      наши элементы, сами элементы, доказательство их равенства и
      мап-функция, то мап-функцию можно применять.

**** Примеры (доказательство симметричности и транзитивности)
     * Симметричность
       Пусть мы умеем доказывать равенство a и b:
       d ∈ Id(A, a, b)
       Построим элемент Id(A, b, a):
       idpeel(A, [x,y,e]Id(A,y,x), a, b, d, [x]id(A, x)) ∈ Id(A,b,a)
       Тогда опишем формально функцию, которая делает, что надо:
       idsymm ∈ (A ∈ Set; a,b ∈ A; d ∈ Id(A, a, b)) Id(A, b, a)
       idsymm(A, a, b, d) = idpeel(A, [x,y,e]Id(A,y,x),
                                   a, b, d, [x]id(A, x))
     * Транзитивность
       Пусть: A ∈ Set; a,b,c ∈ A;
       А также известны доказательства равенств:
       d ∈ Id(A, a, b), e ∈ Id(A, b, c)
       Тогда Воспользуемся стрелочным типом и apply'/λ':
       idtrans ∈ (A ∈ Set; a,b,c ∈ A; d ∈ Id(A, a, b);
                  e ∈ Id(A, b, c)) Id(A, a, c)

       Ну, мы можем сделать такое:
       Inner ≡ idpeel(A, [x,y,p](Id(A,y,c) → Id(A,x,c)), a, b, d,
                      [x]λ'(Id(A,x,c), Id(A,x,c), [w]w))
       Это будет выражение вида Id(A,b,c) → Id(A,a,c).
       Тогда применим к нему выражение e:Id(A,b,c):
       apply'(Id(A,b,c), Id(A,a,c), Inner, e) ∈ Id(A, a, c)

       Что и хотели показать.
**** Подстановка
     subst ∈ (A ∈ Set;
              P ∈ (A)Set;
              a, b ∈ A;
              c ∈ Id(A, a, b);
              p ∈ P(a))
              P(b)
     subst(A,P,a,b,c,p) = apply(P(a), P(b),
                                idpeel(A, [x,y,z](P(x) → P(y)),
                                       a, b, c,
                                       [x]λ(P(x), P(x), [w]w)),
                                p)
*** Set of lists
    Будем строить однотипные (а что если я хочу разнотипные?) листы:
    * List ∈ (A ∈ Set) Set
    * nil ∈ (A ∈ Set) List(A)
      cons ∈ (A ∈ Set, x ∈ A, xs ∈ List(A)) List(A)
      Достаточно канонично
    * listrec ∈ (A ∈ Set;
                 C ∈ (List(A)) Set;
                 c ∈ C(nil(A));
                 e ∈ (x ∈ A, y ∈ List(A); z ∈ C(y)) C(cons(A,x,y));
                 l ∈ List(A)) C(l)
      listrec(A,C,c,e,nil(A)) = c
      listrec(A,C,c,e,cons(A,a,l)) = e(l,a,listrec(A,C,c,e,l))

      Интуиция подсказывает, что listrec -- это рекурсия на листе!
      # Заставить кого-то написать левую свертку, эта -- правая
*** Disjoint unions of two sets (+)
    то сет кусков слева или кусков справа -- inl или inr.
    1. + ∈ (A, B ∈ Set) Set
    2. inl ∈ (A,B ∈ Set; A) A + B
       inr ∈ (A,B ∈ Set; B) A + B
    3. -
    4. -
    5. when ∈ (A, B ∈ Set;
               C ∈ (A + B) Set;
               e ∈ (x ∈ A) C(inl(A,B,x));
               f ∈ (y ∈ B) C(inr(A,B,y));
               p ∈ A + B)
               C(p)
       when(A, B, C, e, f, inl(A,B,a)) = e(a)
       when(A, B, C, e, f, inr(A,B,b)) = f(b)

       Эта связка соответствует логическому ∨.
*** Disjoint union of a family of sets (Σ)
    Это сет пар.
    1. Σ ∈ (A ∈ Set; B ∈ (A)Set) Set
       Отличие от Π в типе второго аргумента -- здесь Set не зависит
       от x, хотя B все еще функция. Тонкой разницы не чувствую --
       пожалуй, и в Π можно было написать (A)B (не уверен).
    2. pair ∈ (A ∈ Set; B ∈ (A)Set; a ∈ A; B(a)) Σ(A,B)
    3. Selector:
       split ∈ (A ∈ Set;
                B ∈ (A) Set;
                C ∈ (Σ(A,B)) Set;
                d ∈ (a ∈ A; b ∈ B(a)) C(pair(A,B,a,b));
                p ∈ Σ(A,B))
                C(p)
       split(A,B,C,d,pair(A,B,a,b)) = d(a,b)

       fst ∈ (A ∈ Set, B ∈ (A)Set; p ∈ Σ(A,B)) A
       fst(A,B,p) = split(A,B, [x]A, [x,y]x, p)

       snd ∈ (A ∈ Set, B ∈ (A)Set; p ∈ Σ(A,B)) B(fst(A, B, p))
       snd(A,B,p) = split(A,B,[x]B(fst(A,B,p)), [x,y]y, p)

       Эта связка соответствует квантору существования.
*** W-types
    * Source
       W-types: good news and bad news:
       http://mazzo.li/epilogue/index.html?p=324.html
    Мы выбираем некоторый сет и строим функцию из его элементов в
    какой-то другой сет. Это очень похоже на Π, но конструктор другой.
    * W ∈ (S ∈ Set; P ∈ (x ∈ S)Set) Set

    Конструктор:
    * sup ∈ (S ∈ Set;
             s ∈ S;
             P ∈ (x ∈ S) Set;
             f ∈ (y ∈ P) W(S, P))
             W(S, P)

      S -- сет.
      P -- семейство сетов, порождаемое каждым элементом из S.
      f -- функция, сопоставляющая каждому элементу семейства P другой
      узел W.

    # {a → b; c → d} -- это анонимный паттерн матчинг!
    ψ -- функция, которая имеет 0 аргументов, соответствует {}.

    Вот вам натуральные числа:
    * mapping = {true → Unit; false → {}} ∈ (x ∈ Bool)Set
    * Nat = W Bool mapping ∈ Set
    * zero = sup(Bool, false, mapping, ψ) ∈ Nat
    * suc (n: Nat) = sup(Bool, true, mapping, {_ → n})

    И еще дерево:
    * mapping = {true → Bool; false → {}} ∈ (x ∈ Bool)Set
    * Tree = W Bool mapping ∈ Set
    * leaf = sup(Bool, false, mapping, ψ) ∈ Tree
    * node(L,R ∈ Tree) = sup(Bool, true, mapping, {true → L, false → R}) ∈ Tree
*** Set of small sets
    U -- universe, это сет, отображающий часть структуры сета на
    объектном уровне, нужен для доказательства неравенств, тайпчекинга
    алгоритмов, создания рекурсивных сетов.
    S -- функция, которая мапает U в элементы.
    * U ∈ Set
      S ∈ (U)Set
    * Конструкторы
      1. Boolᵤ ∈ U
         S(Boolᵤ) = Bool
      2. {}ᵤ ∈ U
         S({}ᵤ) = {}
      3. Πᵤ ∈ (A ∈ U, B ∈ (S(A))U) U
         S(Πᵤ(A,B)) = Π(S(A), [x]S(B(x)))
      4. И так далее
**** Пример доказательства неравенства
     Пусть докажем ¬Id(N,0,succ(0)):
     Найдем элемент в Id(N,0,succ(0)) → {}:

     Для начала пусть x ∈ Id(N,0,succ(0)), то есть от противного.
     Построим Iszero:
     Iszero ∈ (N)U
     Iszero(m) = natrec(m, Boolᵤ, [y,z]{}ᵤ)
     # natrec ∈ (C ∈ (ℕ)Set;
     #           d ∈ C(0);
     #           e ∈ (x ∈ ℕ, y ∈ C(x))C(succ(x));
     #           n ∈ ℕ) C(n)
     Понятно, что:
     Iszero(0) = S(Boolᵤ) = Bool
     Iszero(succ(0)) = S({}ᵤ) = {}

     И тогда:
     true ∈ Bool = Iszero(0)
     # x ∈ Id(N,0,succ(0))
     # true ∈ Iszero(0)
     subst(x, true) ∈ Iszero(succ(0)) = {}

     Тогда этот элемент:
     λ'(Id(N,0,succ(0)), {}, [x]subst(x,true))
         ∈ Id(N,0,succ(0)) → {}

     Причем тут x явно не выписан, заметим, так что противоречия нет.

     Утверждение: без универсума невозможно доказать отрицания
     неравенства.
* Constructive math & programming
** Мотивация
   Очень хочется высокоуровневое программирование.
   Для этого нужен вагон логики.
   Заметим высокое сходство математических сущностей и сущностей из
   программирования (тысячи их):
   |--------------------------------+-----------------------|
   | Programming                    | Mathematics           |
   |--------------------------------+-----------------------|
   | программа, процедура, алгоритм | функция               |
   | input                          | аргументы             |
   | output                         | значение              |
   | присваивание                   | равенство             |
   | S; P                           | композиция функций    |
   | if then else                   | определения по кейсам |
   | integer, real, boolean         | ℤ, ℝ, {0,1}           |
   |--------------------------------+-----------------------|
   Давайте тогда опишем систему.
* Coq manual
   Смотри [[file:./coq_introduction.v][coq_introduction.v]].
** Introduction
   В Coq есть три основных типа: Set, Prop, Type.
   1. Set -- это знакомое уже.
   2. Prop -- это утверждения пропозициональной логики.
      Например, (x ∈ A) B = forall x : A, B
      Аналогично A → B
   4. Type -- тип.

   Типы этих типов выглядят так:
   {Set, Prop, Type(i) | i ∈ ℕ}
   Set : Type(1), Prop: Type(1), Type(i) : Type(i+1).

   Все остальное в coq_introduction.v.
* Докажем, что ¬Id(Nat, 0, 1).
  * Theorem.
    ∀ A type. Id(A, _, _) -- рефлексивное.
    ∀S -- рефлексивное отношение на A: ∀x, y ∈ A Id(A, x, y) → S(x,y)
    1. Рефлексивность Id
       ∀x : Id(A, x, x)
       exact (id x)
    2. Минимальность
       ∀x, y, S : Id(A, x, y) → S(x, y)
       S(x, x) -- работает из-за рефлексивности.
       Делаем rewrite.
    3. Используем теорему о минимальном отношении, теперь
       ∀ f, f -- экстенциональна на A.
  * Докажем, что 0 ≠ 1.
    eq_nat : Nat → Nat → Bool
    eq_nat zero m =  match m with zero => true', succ m' => false'
    eq_nat (succ n) m = match m with zero => false', succ m' =>
    eq_nat n m'

    * Theorem.
      Id(N, x, y) ↔ Is_true(eq_nat(x, y))
      1. ⇒
         Берем Id(N, x, y), делаем substitution(rewrite),
         Докажем Is_true(eq_nat(x, x,))
         С помощью индукции (elim).
      2. ⇐
         Is_true(eq_nat(x, y))
         1. База: x = 0.
            1. y = 0 ⇒ id 0 : Id(N, x, y).
            2. y ≠ 0 ⇒ у нас в предпосылках есть ложь, тогда верно
               Id(N, x, y).
               Тут типа вывели {}, отсюда сделаем case {}, все
               зайдет.
         2. Переход
            Посылка: ∀y : Is_true(eq_nat(x, y)) → Id(N, x, y)
            Докажем: ∀y : Is_true(eq_nat(succ(x), y)) → Id(N,
            succ(x), y)

            Индукция по y.
            1. y = 0, тогда у нас есть ложь и мы можем что угодно
               вывести.
            2. y = succ(u)
               По определению eq_nat сбросим succ(x), succ(y).
               Получим:
               из Is_true(eq, nat(x, u)), получим Id(N, x, u).
               хотим Id(N, succ(x), succ(y))

               Рассмотрим succ : N → N.
               Тогда по экстенциональности succ:
               Id(N, x, y) → Id(N, succ(x), succ(y)).
    * Поскольку мы доказали эквивалентность проверки через set и
      через механику (eq_nat), то возьмем eq_nat(0, 1), и из
      False → Id(N, 0, 1).
* Аксиомы выбора в MLTT
  ∀X : X ≠ ∅, (∀y ∈ X : y ≠ ∅) → (×X ≠ 0)

  Более интуитивное определение:
  S_{w∈W} -- семейство ⇒ ∃(f: w → ∪{w∈W}S_w), ∀w∈W: f(w) ∈ S_w.

** ТТ-аксиома выбора.
   R -- отношение между S и T (первый аргумент из S, второй из T).
   S, T ∈ Set.
   ∀x ∈ S, ∃ y ∈ T : R(x, y) ⇒ ∃f : S → T, ∀x ∈ S : R(x, f(x)).

   * Доказательство
     Построим стрелочный тип ans:
     Π(S, [x]Σ(T, [y]R(x, y))) → Σ(S → T, [f](Π(S, [x]R(x, f(x)))))
     Это будет ровно соответствующее утверждение в нашей теории.

     Заинтродюсим z.
     * z ∈ Π(S, [x]Σ(T, [y]R(x, y)))
     Применим apply:
     * x ∈ S → z(x) ∈ Σ(T, [y]R(x, y))
     Заметим, что:
     * fst(z(x)) ∈ T
       snd(z(x)) ∈ R(x, fst(z(x)))
     Подставим вместо fst эквивалентное выражение:
     * snd(z(x)) ∈ R(x, [y]fst(z(y)))(x)
     Рассмотрим:
     * [y]snd(z(y)) ∈ [f]Π(S, [z]R(z, f(z))).
     Заабстрагируем также fst:
     * [x]fst(z(x)) ∈ S → T
     О, круто, тогда:
     * pair([x]fst(z(x)), [y]snd(z(y))) ∈ нужный тип.
** Сетоиды
   Сетоид -- это пара <S ∈ Set, =ₛ>.
   * Введем понятие экстенционального отношения:
     (x ∈ A, y ∈ B), A, B -- сетоиды.
     R(x, y) экстенционально, если
     ∀x, y ∈ A, u, v ∈ B : R(x, u) ∧ x =ₐ y ∧ u =_b v → R(y, v).
   * f, g : A → B -- экстенциональные функции на сетоидах.
     f, g экстенционально эквивалентны (f =ₑ g), если
     ∀x ∈ A: f(x) =_b g(x).
** ZF-аксиома выбора в терминах сетоидов
   A, B -- сетоиды. R -- экстенциональное отношение на A, B.
   ∀x ∈ A, ∃y ∈ B : R(x, y) → ∃f:A → B (f экстенц., ∀x:R(x, f(x))).
   (экстенциональность для f: ∀ x, y ∈ A, x=ₐy → f(x) =_b f(y))

   Эта аксиома выбора отличается от TT-варианта.

   А вот уникальная аксиома выбора, которая доказуема.
   ∀x ∈ A, ∃!y ∈ B : R(x, y) → ∃f:A → B (f экстенц., ∀x:R(x, f(x))).
   Единственность y. ∃!y значит что R(x, a) и R(x, b), тогда a =_b b.

   * Доказательство последней (уникальной) аксиомы выбора
     Возьмем функцию f из TT-choice.

     Рассмотрим:
     * x ∈ A : R(x, f(x))
       u ∈ A : R(u, f(u))

     Отсюда:
     * x =ₐ u ⇒ R(x, f(u)) ⇒ f(x) =_b f(u).

     Тогда f экстенциональна, и тогда мы получили утверждение.

   * В аксиоме без ! нет условия единственности, у нас f может
     отображать элементы одного класса эквивалентности из A в разные
     классы эквивалентности в B. Эту аксиому нельзя доказать. Более
     того, можно показать, что из аксиомы выбора выводится закон
     исключенного третьего.
** Свойства сетоидов
   * A -- сетоид, тогда |A| -- это сет под сетоидом.
   * f - (|f| : |A| → |B|, ex_proof: extensional A B f)
   * Композиция:
     f : B → C, g : A → B ⇒ f ∘ g : A → C = {h, extₕ}, где
     h = |f|∘|g|
     extₕ = {x =ₐ y → g(x) =_b g(y) → f(g(x)) =_c f(g(y))}
   * Свойства
     1. f =ₑ h ∧ g =ₑ k ⇒ (f ∘ g =ₑ h ∘ k)
     2. h ∘ (g ∘ t) =ₑ (h ∘ g) ∘ f
     3. ∀ x, y, f : X → Y :
        f ∘ idₓ =ₑ f
        id_y ∘ f =ₑ f.
   * Сетоиды являются категориями, а экстенциональные функции
     являются морфизмами.
   * f : X → Y инъективно, если ∀x, y ∈ X : f(x) =y f(y) ⇒ x =ₓ y.
   * f : X → Y сюръективно, если ∀y ∈ Y ∃x ∈ X : f(x) =_y y
   * биективно, если сюръективно и инъективно
   * A, B -- сетоиды, тогда A×B = (|A|×|B|, =ₓ)
     (x, y) =ₓ (u, v) ⇔ x =ₐ u ∧ y_b v.
   * A + B := (|A|+|B|, =ₓ)
     x =₊ y ⇔ (∃a,c ∈ A, Id(|A|+|B|, x, inl(a)) ∧ Id(|A|+|B|, y,
     inl(c)) ∧ a =ₐ c)
     ∨
     (∃b,d ∈ B, Id(|A|+|B|, x, inr(b)) ∧ Id(|A|+|B|, y,
     inr(d)) ∧ b =_b d)
   * Свободный сетоид
     (A, Id(A,_,_)) -- свободный сетоид.
   * Утверждение
     A -- свободный сетоид.
     (∀x ∈ A, ∃y ∈ B: R(x, y)) →
     (∃f : A → B, f экстенциональна : ∀ x ∈ A : R(x, f(x)))

     Доказывается почти так же, как аксиома уникального выбора.
     * Доказательство
       Имеем (из 1 акс. выбора):
       * f : A → B, ∀ x : R(x, f(x))
       Но у нас есть (A, Id(A, _, _)) ⇒ f -- экстенциональна.

** Теорема Диаконеску
*** Общая теорема Диаконеску.
    Пусть P -- утверждение,
    ∃ M -- сетоид,
    f : Bool → M -- сюръекция,
    y : M → Bool -- экстенциональна,
    f ∘ g =ₑ idₘ
    Тогда верно P ∨ ¬P.

**** Доказательство
     M -- (Bool, λxy.(x =_bool y ∨ P))
     Подберем f : Bool → |M|.
     * id : Bool → M будет экстенциональна.
       g : f ∘ g =ₑ idₘ.

     Покажем, что:
     * g(true') =_Bool g(false') ∨ ¬(g(true') =_Bool g(false'))
     Для этого достаточно разобрать случаи (в силу конечности сета
     Bool.
     1. Пусть:
        * g(true') =_Bool g(false')
        Применим к этому нашу функцию f (по экстенциональности).
        * f(g(true')) =ₘ f(g(false'))
        поскольку f ∘ g =ₑ idₘ.
        * true' =ₘ false'
        Отсюда следует, что P верно.
     2. Аналогично получаем:
        * ¬(true' =ₘ false').
        Пусть P верно, тогда true' =ₘ false'.
        Отсюда P неверно.
     Тогда P ∨ ¬P.
*** Частная теорема Диаконеску
    Возьмем общую теорему, заметим что аксиома выбора с
    подставленными вещами будет выглядеть так:
    # Тут мы берем R(x, y) = id'y =ₘ y
    (∀x ∈ M, ∃y ∈ Bool : id'y =ₘ x) →
    (∃g:M → Bool, ∀x ∈ M: id'(g(x)) =ₘ x

    Тогда у нас есть нужная для общей теоремы функция g, отсюда для
    любого P будет верно P ∨ ¬P.
* Алгебраическая топология, вступление
** Деформационная ретракция
   Для понимание гомотопической теории типов нужна гомотопия.
   Для гомотопии нужно знать, что такое топологии, группы и прочее.

   Нарисуем A обычное и добавим к ней straight-skeleton. Получим жиную
   и тощую A. Построим отрезочки между отрезками жирной A и
   тощей. Последовательно все точки жирной A будем стягивать к
   внутренней A. То есть, формально, мы делаем отображение из внешней
   границе к внутренней. В момент времени 0 мы имеем толстую A. В
   момент времени 1 мы хотим тощую. Отсюда точка переходит α пути
   отрезка за время α.
   Пусть жирная буква A -- это X, а тонкая A -- это A.

   Деформационная ретракция X на A ⊂ X -- это семейство отображений
   fₜ: X → X, t ∈ I, для которого:
   1. f₀(X) = id
   2. f₁(X) = A
   4. ∀t ∈ I, fₜ|ₐ = id.
   5. f непрерывно по обоим параметрам
** Ретракция
   Ретракция из X на A -- это такое f , что:
   f|ₐ = 1, f(X) = A
** Примеры деформационных ретракций
   Можно сделать разные объекты ретракций -- нарисуем плоскость с
   двумя дырками. Можно нарисовать вокруг них очки и знак
   бесконечности. Внешнее множество стягивается к каждому из
   последних, но друг в друга они не стягиваются. Короче, нужно
   отображение посильнее.
** Гомотопия
   Откажемся от вложенности стягиваемых множеств.

   Семейство fₜ: X → Y -- гомотопия, если:
   F(x, t) = fₜ(x) непрерывно. F: X × I → Y.

   Гомотопию можно устраивать на чем угодно, в том числе на
   отображениях.

   f₀, f₁ готомотопны (f₀ ≃ f₁), если существует гомотопия, их
   связывающая. fₜ: X → Y.
** Деф. ретракция как гомотопия
   Деформационная ретракция X на A -- это гомотопия из (id на X) в
   ретракцию на A.
** Задачка на гомотопию
   1. Построить ретракцию из тора с одной выколотой точкой на граф из
      двух окружностей, пересекающихся в одной точке.

      При этом важно обратить внимание на непрерывность -- две рядом
      стоящие точки не должны быть далеко друг от друга в любой момент
      времени гототопического преобразования.

      Решение -- взять одну окружность вдоль "хребта" тора, другую --
      поперек.
      Растягиваем дырку вдоль хребта, потом к мередиану.
   2. Построить дефракцию ℝⁿ\{0} на Sⁿ⁻¹ -- на сферу.
      По индукции, выписать явную формулу.
** Клеточный комплекс
** Гомотопическая эквивалентность
   f: X → Y, если есть g: Y → X: fg ≃ id, gf ≃ id.
   Будем называть множества готомопичечки эквивалентными, если между
   ними существует гомотопическая эквивалентность.

   В частном случае
   A ⊂ X, fₜ: X → X деформационная ретракция
   i: A → X -- включение.
   r: X → A -- ретракция
   i∘r ≃ id, r∘i = id.
** Цилиндр отображения
   X, Y -- гомотопически эквивалентны, тогда найдется Z, что Z
   деформационно ретрактируется в X и в Y. При этом Z -- цилиндр
   отображения X в Y (все пути гомотопии).

   * Пример:
     Представим себе тонкую 'A' внизу и толстую 'A' наверху (одна над
     другой в ℝ³).
     вверху. Отображение F(1/2, x) будет отображать в половину
     посередину цилиндра отображения. А весь этот тридэ конус будет
     являться цилиндром отображения.
** Задачки на гомотопическую эквивалентность
   1. f: X → Y, g: Y → Z ⇒ g∘f: X → Z
      * Симметричность очевидна из определения гомотопической
        эквивалентности.
      * Рефлексивность очевидна из того, что мы можем взять f = id.
        Транзитивность: f₁: X → Y, f₂: Y → Z, g₁: Y → X, g₂: Z → Y.
        Тогда возьмем функции f₂∘f₁, g₁∘g₂. Композиция непрерывных
        функций непрерывна.
   2. f: X → Y, h ≃ f. Показать, что h -- гомотопическая
      эквивалентность.
      g: Y → X -- обратная к f.
      h: X → Y.
      * Покажем, что если f ≃ h, то f∘g ≃ h∘g ≃ id.
        h₀ ≃ h₁, hᵢ: X → Y.
        H(x, t) = hₜ(x) -- непрерывна.
        g: Y → Z -- непрерывна.
        g∘hᵢ -- непрерывна
        g∘hᵢ: X → Z
        g∘h₀ ≃ g∘h₁
      * Отсюда скажем, что g -- обратная и к h.
        Тогда h∘g ≃ f∘g ≃ id.
        Аналогично и справа. Тогда h действительно гомотопия.
   3. Деормационная ретракция X на A в слабом смысле: A ⊂ X -- это
      такая гомотопия fₜ: X → X, f₀ = id, f₁(X) = A, fₜ(X) = A.
      Разница с обычной ретракцией f|ₐ = id, а тут A может
      колебаться.

      Показать, что если X деформационно ретрактируется на A в слабом
      смысле функцией f, то включение l: A → X -- гомотопическая
      эквивалентность.
      Найдем такую g: X → A, что g∘l ≃ id, l∘g ≃ id.
      Это значит, что мы найдем:
      * G(x, t) = if t=0 then g ∘ l elseif t=1 id
      f₀∘l = l
      f₁∘l ⊂ A
      Не решено.
   4. Дом с двумя комнатами.
      Пространство X стягивается в точку, если оно гомотопически
      эквивалентно точке ({0}).
      Возьмем прямоугольную коробку и горизонтально разрежем ее
      пополам. Добавим два входа -- с крыши на 1 этаж, с подвала на 2
      этаж. И еще есть 2 стенки.

      Покажем, что дом эквивалентен точке.
      Раздуеем все стенки, протаскиваем через дырку. Короче
      пенопластом залили дырки. Получили кубик. Кубик стягивается в
      точку.
      Можно сделать без заполнения пеной.

      Этот пример нагляден тем, что если мы можем найти такое Z, что Z
      ретрактирует в A, в B, отсюда A ≃ B.
** Клеточный комплекс
   Eⁿ⁻¹={eₖ}, k < n. Eⁿ = Eⁿ⁻¹∪{eₖⁿ}/φₖ (фактор по некоторому
   отображению склейки).
   φₖ : Sⁿ⁻¹ → Eⁿ⁻¹. Тогда E -- клеточный комплекс.
   Если E=Eⁿ, то E конечномерен.
** Склеивания
   Будем рисовать фигурки со стрелочками на боках, чтобы показать, как
   мы будем сворачивать прямоугольник.
   Покажем, что тор можно определить иначе.
   Исходя из предыдущего задания можем сделать граф из двух
   окружностей с помощью склеивания e⁰, 2×e¹. eⁿ -- это сфера в
   n-мерном пространстве. Тогда e⁰, 2×e¹, e² -- это тор.

   Аналогично склеив e² и e⁰ можно получить сферу в ℝ².

   E¹ - граф.
** Примеры клеточных комплексов
** Проективное пространство
   Рассмотрим точку. Все прямые, проходящие через конкретную точку.
   Тогда приближая какие-то прямые к точке, будем приближаться к
   бесконечности. То есть набор прямых и выделенное направление.
   ℙℝⁿ -- проективное пространство над ℝⁿ.

   Тогда ℙℝⁿ эквивалентно полусфере, поскольку мы отождествляем каждой
   прямой только одно направление. Полусфера эквивалентна шару
   предыдущей размерности. Кроме того, эта полусфера требует
   факторизации нижней границы, потому что все бесконечности
   эквивалентны.
   Утверждается, что ℙℝⁿ эквивалентно ℙℝⁿ⁻¹.
   ℙℝⁿ = {eⁿ,eⁿ⁻¹,...e⁰}

   N-мерное пространство эквивалентно N+1-мерной единичной полусфере,
   у которой мы факторизуем границу.
   ТО есть n-мерное проективное пространство есть приклеивание
   n-мерной ячейки с n-1м проективным пространством.
** Подкомплекс
   A ⊂ X. x - CW. A замкнуто, объединение некоторых клеток из x.
   (X, A) -- CW-пара (комплекс и подкомплекс).
** Задача на подкомплекс
   Построить 2-мерный CW-комплекс, что он содержит как S¹×I, так и
   лист Мёбиуса.
** Произведение пространств
   Eₐ×Eb = {eₐᵏ×eˡb}.
   Что такое S₁×S₁?
   S₁ = {e₁, e₀}.
   Тогда e₀×e₀ = e₀.
   e₁×e₀ -- окружность.
   e₀xe₁ -- тоже.
   Таким образом, получим тор.
** Факторпространство
   (X, A) -- CW-пара.
   X / A -- это все клетки из X \ A ∪ {0}, где ноль -- образ для всех
   клеток из A.
   eⁿ ∈ X\A, φ: Sⁿ⁻¹ → Xⁿ⁻¹.
   Новое отображение φ': Sⁿ⁻^1 → Xⁿ⁻¹ →{ψ}→ Xⁿ⁻¹/Aⁿ⁻¹.ы
** Надстройка
   Для X надстройка SX: R = X×[0,1]/(t,0)/(t,1)

   X = S¹. Тогда сначала сделаем цилиндр. Стянем верх и низ в точки --
   получим сферу ℝ².
** Джойн
   A*B = A×B×I / (a, _, 0) / (_, b, 1).

   Возьмем две прямые I: I×I×I -- куб. Слева объединяем по одной
   координате, справа по другой. Получим тетраэдр.

   * Проверим, что S¹*S¹ = S³?
     S¹×S¹×I -- это бублик, существующий секунду.
     Тогда в первый момент времени бублик -- шнур. Потом он толстеет и
     становится сферой.
** Свойство продолжения гомотопии
   f₀: X → Y, A ⊂ X. fₜ: A → Y -- гомотопия.
   Если fₜ можно всегда прожолжить до гомотопии fₜ: X → Y, то пара
   (X, A) обладает свойством продолжения гомотопии.

   (X, A), X = I, A = {1, 1/2, 1/3, 1/4, ..., 1/n, ..., 0}.
   Решим эту проблему с помощью следующей теоремы.
   А потом можно без проблемы -- возьмем в качестве Y нашу расческу,
   она будет работать. Предел по вершинам гребней будет (1,1), тогда
** Теорема о продолжении гомотопии
   Пара (X, A) обладает свойством продолжением гомотопии ⇔
   (X × {0}) ∪ (A × I) -- ретракт X × I.

   1. Доказательство слева направо очевидно, так как id на (X ×
      {0})×... продолжается на X×I→...

   2. Обратное:
      Пусть A замкнуто в X. Возьмем X × {0} → Y, A × I → Y. Они
      согласуются на A × {0}.
      Общее отображение -- X × {0} ∪ A × I → Y. Возьмем ее композицию
      с ретракцией X × I → X × {0} ∪ A × I, получим продолжение
      X × I → Y.
** О всяких дефомационных ретрактах
   Пусть (X, A) -- CW-пара, тогда (X×{0})∪(A×I) -- деформационный
   ретракт пространства X × I, поэтому (X, A) обладает свойством
   продолжения гомотопии.

   Доказательство с помощью редукции бадей из предыдущей теоремы.
** Утверждение ??
   Если (X, A) обладает свойством продолжения гомотопии и A --
   стягиваемо, то отображение факторизации q: X → X / A есть
   гомотопическая эквивалентность.

   fₜ: X → X -- гомотопия, подолжающая стягиваание A, f₀ = id.

   fₜ(A) ⊂ A. Значит, q∘fₜ : X → X / A переводит A в точку.

   Тогда X →q→ X/A →fₜ→ X/A

   #+BEGIN_SRC ditaa :file lol.png
      fₜ
   X ------→ X
   |     /→ |
   |q  g/   |q
   ↓  /  fₜ ↓
   X/A ---→ X/A
   #+END_SRC

   f₁(A) = Z -- точка, куда стягиваем A. g : X/A → X.
* Пути, фундаментальные группы
** Пути и петли
   Путь -- это непрерывное отображение из I в X -- топологическое
   пространство.

   При этом, очевидно, f(0) -- начало. f(1) -- конец. Если f(0) =
   f(1), то f -- петля.

   Не важно, что происходит с путем -- он может много раз себя
   пересекать или накладываться.

   Будем пользоваться синтаксисом: f: I 0 1 → X a b.
** Гомотопия
   Гомотопия -- это семейство путей fₜ: I → X, ∀t ∈ I. Причем важно
   условие равенства концов: ∀t fₜ(0) = a, fₜ(1) = b.

   * Отношение "быть гомотопным" является отношением эквивалентности.
     Доказательство очевидно.
** Пример гомотопии
   Возьмем какое-нибудь плотное множество O ⊂ ℝⁿ. O выпукло. Возьмем
   два пути -- f₀, f₁. Можем устроить между ними гомотопию:

   fₜ = (1-t)f₀(s) + tf₁(s).
** Произведение путей
   Если у нас есть путь из f из a в b и путь g из b в c, то можем
   сделать путь (f ∘ g) из a в c. Просто продлеваем отрезок до двойки,
   потом сужаем до единицы.

   Тогда при f: I 0 1 → X a b, g: I 0 1 → X b c ⇒ f∘y: I 0 1 → X a c.

   * Утверждается, что при f ≃ f', g ≃ g' ⇒ f∘g ≃ f'∘g'.
     Ну вот у нас есть fₜ, gₜ. Возьмем Hₜ = fₜ∘gₜ.
** Фундаментальные группы
   Группа, это, как мы помним -- множество <Set, |∘|:G×G ⇒ G,
   e:G, |∘|⁻¹:G → G>. Причем есть ассоциативность на операции,
   коммутативность с единицей = a. Произведение a*a⁻¹ = e.

   X, x₀ ∈ X. f -- петля ⇒ [f] -- класс эквивалентности петель по
   гомотопности f.
   G = {[f] | f : I 0 1 → X x₀ x₀}.

   Будем брать за обратное отображение обратный путь по петле.
   Будем брать за нейтральный элемент путь e = Cₓ₀(s) = x₀.

   Вот Π(X,x₀) -- фундаментальная группа.

   Еще в группах есть возведение в степень:
   a⁰ = e.
   aⁿ⁺¹ = aⁿ*a, n ≥ 0
   a⁻ⁿ = (aⁿ)⁻¹ = (a⁻¹)ⁿ.
** Пример фундаментальной группы
   Возьмем пространство [-1,1]²\{0}. Тогда для любой точки кроме 0 все
   петли имеют бесконечное количество классов эквивалентности --
   бывают петли, которые не охватывают точку, бывают те, которые
   охватывают точку, причем нужно учитывать число оборотов вокруг
   выколотой точки.

   В этом примере пути, которые не охватывают точку -- нейтральный
   элемент. Произведение таких элементов есть ровно такой же
   элемент. Аналогично произведение нейтрального элемента и петли,
   охватывающей 0 есть вторая петля, охватывающая 0.

   Тогда если есть петля f, то f*f⁻¹ = e.
** Доказательство того, что ФГ -- группа
   1. Возьмем цепь f∘g∘h -- три пути.

      [f∘(g∘h)]] = [(f∘g)∘h] -- покажем это. То есть докажем
      гомотопность.

      Это очевидно, просто будем идти по цепи с разной
      скоростью. Конечно, такие пути гомотопны.
   2. Возьмем путь f, c₁. Покажем, что f ∘ c₁ ≃ f. Это мы типа идем по
      f, а потом стоим в крайней точке b.

      Воспользуемся перепараметризацией пути.
      φ: I 0 1 → I 0 1.
      f: I 0 1 → X a b. Тогда φ∘f: I 0 1 → X a b.

      Параметризация не меняет класс эквивалентности. Это так, потому
      что и φ и ψ принадлежат отрезку -- выпуклому множеству в
      ℝⁿ. Значит они гомотопны, тогда f∘φ ≃ f∘ψ.

      Возьмем ψ = id, φ = id∘c₁.
      Тогда f∘φ = f∘(id∘c₁)
   3. f: I 0 1 → X a b.
      f~: I 0 1 → X b a.

      f∘f~ ≃ cₐ. f~∘f ≃ c_b.

      Возьмем φ = id*id~ = I 0 1 → I 0 0. ψ = C₀.

      f∘φ = f∘(id∘id~) = (f∘id)∘(f∘id~) = f∘f~.

      f∘ψ = f∘c₀ = cₐ.
** Изоморфизм групп
   Мы хотим избавиться от точки в определении ФГ.
   Руками помахать -- это если мы умеем строить для двух x₀ путь между
   ними, то они изоморфны, то есть будут иметь одинаковые ФГ.

   * G, H -- группы.
     f: G → H -- гомоморфизм групп, если ∀a,b, f(a∘b) = f(a)∘f(b).
   * G, H -- группы. Тогда f: G → H -- изоморфизм, если.
     1. f -- гомоморфизм G → H.
     2. ∃f⁻¹.
     3. f⁻¹ -- гомоморфизм H → G.
   * В группах из первых двух свойств изоморфизма следует третье. То
     есть обратная функция к гомеоморфизму тоже есть гомеоморфизм.

     f⁻¹(f(f⁻¹(s*t))) = f⁻¹(f(f⁻¹s) * f(f⁻¹t)) = ...
     Типа такого доказательство.
** Свойства изоморфности групп
   Если существует β: I 0 1 → X x₁ x₀, тогда Π₁(X,x₀) ≈ Π₁(X,x₁).

   Возьмем Φ: Π₁(X,x₀) → Π₁(X,x₁).

   Φ(f) = β*f*β⁻¹.
   Φ(f): I 0 1 → X x1 x₁.

   1. Φ(f*g) = β*f*g*β⁻¹. Тогда
      Φ(f)*Φ(g) = β*f*β⁻¹*β*g*β⁻¹.
   2. Φ⁻¹(g) = β⁻¹*g*β. Это будет нормальный обратный элемент, так как
      Φ(Φ⁻¹(g)) = ββ⁻¹gββ⁻¹ ≃ g.

   Есть свойство еще:
   * Если X -- связно, то ∀x₀,x₁ ∈ X Π₁(X,x₀) ≈ Π₁(X,x₁).
     Пишут тогда просто Π₁(X).

   И определение:
   * X -- односвязно, если
     1. X связно
     2. Любые две петли гомотопны (∀f,g -- петли f≃g).
** Π₁(S¹)
   Очевидно, что это группа целых чисел, потому что мы можем
   повернуться сколько-то раз в какую-то сторону, поэтому количество
   оборотов -- это модуль, а направление -- это знак.

   wₙ -- это ровное количество оборотов n в одну сторону.
   * wₙ: I 0 1 → S¹ 0 0

   Φ: ℤ → Π₁(S¹).
   * Φ(n) = [wₙ].

   Определим w получше:
   * w₁(t) = <2πt> : I → S¹.
   * wₙ(t) = <2n*πt> = (w₁)ⁿ.

   Покажем, что Φ -- изоморфизм.
   1. Φ(m+n) = Φ(m)+Φ(n) -- доказать, что ([w₁])ᵐ⁺ⁿ ≃ [w₁]ᵐ*[w₁]ⁿ.
   2. Найдем обратное.
      Φ⁻¹: Π₁(S¹) → ℤ.

      p: ℝ → S¹. Рисуем петлю в ℝ³, спираль идет из нее вверх и вниз.
      ψ: ℝ → ℝ³.
      ψ(t) = <1, 2πt, t>cyl
      p: ℝ → S¹.
      p(t) = <1,2πt>pol.

      Для любой точки на спирали есть единственый путь в точку на
      окружности, которая является проекцией нашей точки на
      окружность.
   3. Построим p: ℝ → S¹.
      p(s) = <2πs>
      ψ(s) = <1,2πs,s>cyl -- спиралька.
      Тогда возьмем любую точку на спирали ψ(s), тогда p(s) -- ее
      проекция на окружность.

      Возьем какой-то путь на спирали: wₙ~ : I 0 1 → ℝ 0 n, где n∈ℕ.
      Тогда для него верно wₙ~(s) = n*s.

      Утверждение: (p∘wₙ~)(t) = wₙ(t).

      Мы можем выбрать такую точку a~, что если f путь на окружности,
      то f~ на спирали единственный, если начинается с a~.

      Покажем, что Φ сюрьективно и конъюнктивно.
      * Сюръекция:
        Пусть f : I 0 1 -> S 0 0. Возьмем a~ = 0 ∈ ℝ. Тогда существует
        единственный f~, что p∘f~ = f. f~: I 0 -> ℝ 0.

        (p∘f~(1) = f(1) = 0)

        <2π*f~(1)> = 0.
        K := f~(1) ∈ ℤ.
        f~ : I 0 1 → ℝ 0 K
        wₖ~: I 0 1 → ℝ 0 K
        f~ ≈ W~ₖ
        f = p∘f~
        wₖ = p∘f~

        f = wₖ.
        Ну вот чето мы нашли нужное K.

      * Инъективность
        Φ(m) = Φ(n) ⇒? m = n

        wₘ ≃ wₙ
        fₜ: wₘ ≃ wₙ
        f₀ = wₘ, f₁ = wₙ
        wₘ,wₙ: I 0 1 → S 0 0
        a~ := 0 ∈ ℝ
        wₘ~, wₙ~: p∘wₘ~ = wₘ~. p∘wₙ~ = wₙ.

        b:= wₘ~(1) = wₙ~(1).

        wₘ~,wₙ~ : I 0 1 → ℝ 0 b
        m = b, n = b.

        m = n.
      * Y -- топологическое пространство.
        F : Y×I → S¹.
        F₀~: Y × {0} → ℝ.
        p∘F₀~ = F|_{Y×{0}}

        Тогда ∃!F~: Y×I → ℝ, что:
        1. F~|_{Y×{0}} = F₀~
        2. p∘F~ = F

        Если мы докажем это, то все будет окей.
        Показываем сначала следствие из этого в a, b, из которых
        дальше следует инънективность и сюръективность.

        В общем все доказывается, но доказательство очень плохое.
      * Докажем собственно само утверждение предыдущее
        1. Y -- ТП. F: Y × I → S¹. F₀~; Y × {0} → ℝ,
           p ∘ F₀~ = F|_{y×{0}}, y₀ ∈ Y.

           Тогда ∃N = Cl(y₀). ∃F~: N × I → ℝ:
           1. F~|_N×{0} = F₀~
           2. p∘F~ = F.
        2. b ∃~F~:[y₀}×I → ℝ.
      * ∃{Uₐ}: ∀a Uₐ -- открыто, Uₐ ⊂ S¹. ⋃Uₐ = S¹.
        ∀a₀. ∃{Aᵢ} : p⁻¹(Uₐ₀) = ⋃Aᵢ
        ∀i≠j, Aᵢ∩Aⱼ = ∅, ...

        Из вот этого следует все остальное, а само оно все ок.
** Применение Π₁
   Пусть P : ℂ → ℂ -- это полином в комплексных числах.
   P = zⁿ + ∑{i=0..n-1}aᵢzⁱ, n>0.

   Тогда у него есть z₀, что p(z₀) = 0.

   * Предположим, что корней нету.

     ∀z, p(z) ≠ 0.

     fᵣ(s) = (p(re^(2πis))/p(r))/ | (p(re^(2πis))/p(r)) | --
     нормированное чето.

     Поскольку мы каждое число нормируем, то они все лежат на
     единичной окружности.

     fᵣ(0) = 1.
     fᵣ(1) = 1.

     ∀r,fᵣ: I 0 1 → S¹ 1 1.

     ∀r₁,r₂ fᵣ₁ ≃ fᵣ₂.

     f₀(s) = 1, f₀ ≃ const.

     Все пути гомотопны f₀, тогда они все стягиваемы.

     Возьмем r: r > ∑aᵢ, r > 1.
     Пусть |z| = r ⇒ |zⁿ| = r*|zⁿ⁻¹| > (∑|aᵢ|)|zⁿ⁻^1| = ∑|aᵢ|*|zⁿ⁻¹|
     > ∑|aᵢ||zⁱ|

     pₜ(z) = zⁿ + t*∑aᵢzⁱ, t ∈ [0,1].

     Тогда |z| = r ⇒ pₜ(z) ≠ 0.

     Возьмем p₀(z) = zⁿ. p₁(z) = 0.

     Пусть fᵣᵗ -- это как fᵣ, только все p внутри параметризованы t.
     Получим f⁰ᵣ ≃ f¹ᵣ. = const. fᵣ ≃ f₀ = const.

     fᵣ⁰(S) = e^(2πisn)/|e^(2πisn)| = e^(2πisn) = <2πns>. -- это wₙ.
     Поскольку fᵣ⁰ = const, то wₙ = 0. Тогда степень полинома 0, но мы
     предполагали, что она больше нуля. →←
** Группа произведения
   Пусть есть группы G,H. Тогда можно сделать G×H -- группы, что
   <a,b>*<a',b'> = <a*a', b*b'>.
   e_G×H = <e_G,e_H>.
   <a,b>⁻¹ = <a⁻¹,b⁻¹>.

   Это работает, очевидно.
** Функциональная группа произведений
   Π₁(X×Y, (x₀,y₀)) ≈ Π₁(X,x₀)×Π(Y,y₀).

   Это доказывается очевидно. Вправо -- берем петлю в X×Y, в качестве
   подпетель берем проекции. Влево -- берем петли в пространствах,
   фиксируем t, рисуем в X×Y петли.

   Π₁(S¹×S¹) ≈ ℤ×ℤ.

   Можно рассмотреть произвольный пример петли на торе и сопоставить
   ей количество оборотов по мередиану и широте.
** Индуцированные гомоморфизмы
   Мы умеем сопостовлять X ↔ Π₁(X). Можем сопоставлять X → Y. Но можем
   ли сопоставлять Π₁(X) → Π₁(Y)?

   Пусть X -- топологическое пространство, x₀ ∈ X, <X,x₀> -- ТП с
   отмеченной точкой.

   От отображений X → Y будем требовать непрерывности, плюс сохранения
   этой выделенной точки. f:<X,x₀> → <Y,y₀>, если f(x₀) = y₀.

   Пусть φ: <X,x₀> → <Y,y₀> тогда определим гомоморфизм между
   функциональными группами:

   φ⋆: Π₁(X,x₀) → Π₁(Y,y₀).
   f ∈ Π₁(X,x₀)
   f : I 0 1 → X x₀ x₀
   φ⋆f: I 0 1 → Y f₀ f₀
   φ⋆f = φ∘f.


   * ∀φ φ⋆ - гомоморфизм.
     φ⋆(f∙g) = φ⋆f∙φ⋆g
     φ∘(f∙g) = (φ∘f)∙(φ∘g)

   * (φ∘ψ)⋆ = φ⋆∘ψ⋆.
     idₓ : <X,x₀> → <X,x₀>
     (idₓ)⋆ = id_Π₁(X,x₀)

     Доказывается банальным раскрытием определения.

   * φ -- гомеоморфизм ⇒ φ* - изоморфизм.
     Поскольку φ -- гомеоморфизм, то ∃ψ.
     φ∘ψ = id
     ψ∘φ = id

     Нужно только показать, что φ⋆⁻¹ = ψ⋆.

     То есть, что φ⋆∘ψ⋆ = id, ψ⋆∘φ⋆ = id.

     id = id⋆ = (φ∘ψ)⋆ = φ⋆∘ψ⋆.

   * <X,x₀> ≈ <Y,y₀> ⇒ Π₁(X,x₀) ≈ Π₁(Y,y₀).
   * Sⁿ\{x} ≈ ℝⁿ. Это типа очевидно.
   * Π₁(Sⁿ\{x}) ≈ Π₁(ℝⁿ) = 𝟙 = {e}.
** Функциональные группы для сферы
   Для любых n ≥ 2 Π₁(Sⁿ) = 𝟙.

   f: I 0 1 → Sⁿ x₀ x₀.
   f(I) -- множество всех точек, через которые проходит петля.
   Возьмем какое-то a ∉ f(I) ⇒ f стягивается.

   Такое a всегда есть. Пусть нету. Тогда все петля занимает всю
   сферу. В этом случае можно аккуратно найти f~ ≃ f, что f~ не
   проходит через b.

   Для любой точки через нее проходит конечное множество путей (так
   как I компакт). Аналогично конечно количество кусков петли,
   проходящих через любую окрестность. Тогда можно мапать петлю по
   краю.
** Функциональная группа для ℝ\{x}
   ℝ¹ -- несвязное множество, мы на такое не смотрим.

   ℝⁿ\{x} ≈ Sⁿ⁻¹×ℝ. Типа возьмем эту точку и построим из нее полярные
   координаты. Тогда будут ровно две проекции.

   Отсюда Π₁(ℝⁿ\{x}) ≈ Π₁(Sⁿ⁻¹×ℝ) ≈ Π₁(Sⁿ⁻¹)×Π₁(ℝ) =
   { если n = 2, ℤ×𝟙 = ℤ.
   { если n ≥ 3, то 𝟙×𝟙 = 𝟙.

   * ∀n ≥ 3, ℝⁿ ≉ ℝ².
     От противного. Пусть ℝⁿ ≈ ℝ². f -- гомеоморфизм.
     ℝⁿ \ {x} ≈ ℝ² \ {f(x)}. Типа просто сузили область определения f.

     Π₁(ℝⁿ\{x}) ≈ Π₁(ℝ²\{f(x)}), но 𝟙 ≈ ℤ.

     Если n = 1, то аналогично представим, выберем точку, но несвязное
     не гомеоморфно связному.
* Теорема Брауэра о неподвижной точке
  Рассмотрим шар D². Рассмотрим функцию f: D² → D².

  Тогда существует x ∈ D², что f(x) = x.

  Брауэр это доказал, а потом подумал, что все фигня и занялся
  интуиционистской логикой.

  От противного. Пусть ∃f: D² → D², что ∀x∈D², f(x) ≠ x.
  Тогда очевидно, что Sf(x) непрерывно. Sf(x) строит луч из f(x) через
  x, пока он не уткнется в S.

  Очевидно, для x ∈ S¹, что Sf(x) = x.

  Тогда Sf -- ретракция.

  Возьмем какую-то петлю p на S¹. В D² петля стянется в точку. Пусть в
  точку x₀ ∈ S¹.

  Тогда мы можем непрерывно отмапать любую петлю сначала в D, стянут и
  отмапать обратно в ℝ².

  Противоречие -- фундаментальная группа S¹ содержит только один
  элемент.
