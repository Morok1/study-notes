#+LANGUAGE: ru
#+TITLE: Software Design (kirakozow)

* Code style
  * Называть переменные очевидно.
  * Не пользоваться магическими константами
  * Классы -- существительные
  * Методы -- глаголы или set/get/modifyX.
  * Венгерская нотация -- для java/c/c++ набор сокращений -- не
    нужна.
  * Если система типов не позволяет сделать лучше, указывать тип в
    имени (миллисекунды и т.д.).
  * Лучше пользоваться математическими терминами где это уместно.
  * Null/optional
    * Аннотации Nullable/NotNull
    * Optional/Maybe -- лучше, но немного сложнее хэндлить и
      создаются ненужные объекты.
* Correctness guarantees
  * Обеспечивать корректность можно: формальные доказательства,
    верификация, автопроверки, code review, авто/ручное
    тестирование.
  * Этапы багов: локальный, на интеграции/тестировании, в
    деплойменте или бета-тестировании.
  * CI с тестами -- это хорошо. Лучше, если еще и деплоит.
  * Что может проверить компилятор, почему статическая типизация
    лучше.
  * Инструменты для статического анализа -- checkstyle, sonar,
    findbugs.
  * Для того что нельзя проверить статически, проверять входные
    данные и делать защиту от дурака.
  * Что делать на некорректных данных -- фиксить, падать с
    ошибкой, запросить заново.
  * Assert'ы -- хорошо. Программирование по контракту -- хорошо.
  * LiquidHaskell -- prove laws, correction check, termination
    check, pointers within bounds.
* Exception handling
  * Глобальные переменные с кодом ошибки, возвращать код ошибки в
    методе, исключения.
  * В java -- Error (jvm), Unchecked (RuntimeException, не требуют
    декларации), Checked.
  * Checked -- понятно, но громоздко. Неудобно для
    лямбд. Unchecked -- наоборот.
* TDD/modular testing
  * Статические проверки -- недостаточно хорошо. Приемочные тесты
    -- все целиком как черный ящик. Модульные тесты -- запускаются
    на каждый коммит, гранулярные.
  * Модульное тестирование.
    * Фикстуры -- позволяют инициализировать стейт до и убрать
      после. Готовят входные данные, инициализируют моки,
      загружают бд. Аннотации @before{Class}*.
    * Assume -- скипать тесты автоматически
  * Когда писать -- как можно раньше, вместо отладочного запуска.
  * При ошибке -- написать тест, который ее воспроизводит.
  * TDD -- сначала тесты, потом код.
  * Зачем писать тесты: руками сложно, фиксят баги, уверенность
    при модификации, улучшают дизайн (потому что пользуются api),
    дают дополнительное описание как этим пользоваться.
  * Полезно следить за покрытием. Покрыть все сложно, но лучше
    покрыть больше, чем забить.
  * Для легкого кода легко писать тесты.
* OOP SOLID
  * Singe responsibility principle -- не должно быть более одной
    причины для изменения класса. Каждый класс имеет ровно одну
    функциональность, изменения в которой мы считаем
    атомарными. Классы не должны объединять много
    функциональностей.
  * Open closed principle -- сущности должны быть открыты для
    расширения, но закрыты для модификации. Мы смотрим на класс и
    можем только аппендить к нему функциональность причем так,
    чтобы не трогать старый код.
  * Liskov substitution principle -- объекты должны быть заменяемы
    на свои подтипы без нарушения коррекности. Как нельзя делать
    -- наследовать классы и делать затычки на ту функциональность,
    которой мы не предполагаем, типа кидать эксепшн на метод,
    которым мы не пользуемся, потому что в child class'е он не
    имеет смысла.
  * Interface segregation principle -- много специфичных
    интерфейсов лучше, чем один.
  * Dependency inversion principle -- сущности должны зависеть от
    абстракций, а не от конкретики. Скажем, если мы пишем систему
    нотификаций, то лучше ввести class Sendable или как можно выше
    абстрагировать то, что мы отправляем, чем ссылаться на
    конкетный класс `Message`.
* Testability
  * Testability -- это важный параметр системы. сложно
    тестируемые системы -- плохие (субъективно, конечно).
  * Mock -- добавляем фейковые зависимости и тестируем логику
    класса, а не зависимостей. Зависимости протестированы своими
    тестами.
* Refactoring
  * Процесс изменения структуры приложения без изменения внешнего
    поведения, с целью упростить понимание и расширяемость.
  * Как делать -- не добавлять фич, делать локально и понемножку,
    проверять что тесты проходят.
  * Когда -- правило трех: первый раз писать чтобы работало,
    второй раз бахать, но забивать, третий раз рефакторить. Еще
    когда добавляешь фичу. Когда фиксишь баги. Когда делаешь code
    review.
  * Code smells:
    1. Нагромождения -- большие методы, большие классы, куча
       параметров метода, много простых типов вместо
       объектов. Недостаточно обобщенные вещи, которые
       накапливаются.
    2. ООП нарушители -- неверное использование принципов
       ООП. Использование switch/multiif вместо классов и
       наследования. Временные поля (которые хранят мусор почти
       все время). Использование статических классов вместо
       наследования. Похожие классы с разными интерфейсами.
    3. Противники изменений:
       * Расходящиеся модификации -- для добавления маленькой фичи
         нужно дописать функционал в 5 мест.
       * Стрельба дробью -- изменение затрагивает очень много
         мест.
       * Параллельные иерархии наследования -- например для
         иерархии A <- B <- C есть AFormatter <- BFormatter <-
         CFormatter.
    4. Мусорный код -- комменты, дублирование, копипаст, классы,
       чрезмерная абстрактность, мертвый код.
    5. Чрезмерные связи -- завистливые функции (пользуются чаще
       чем-то левым, чем своим), неуместная близость (много
       зависимостей), цепные вызовы методов.
  * Простые рефакторинги: извлечение и встраивание метода,
    извлечение константы, перемещения и переименования.
  * Замена switch на полиморфизм -- объект сам знает что делать.
  * Разделение запросов и модификаторов объектов -- если это возможно.
  * Обертки и самоинкапсуляции.
  * Замена конструктора на фабрику. Можно возвращать потомков
    класса или уже созданный объект.
  * Замена наследования на делегирование (храним бывшего родителя
    как поле).
* Patterns.
  http://www.mcdonaldland.info/files/designpatterns/designpatternscard.pdf
  * Бывают порождающими (создают новые объекты), структурные
    (композируют объекты), паттерны поведения (распределяют
    обязанности в системе).
  * Порождающие
    1. Абстрактная фабрика: создание семейств объектов различных по
       каким-то свойствам. Типа вот семейство виджетов
       параметризовано по тому, где они рисуются -- на бэкэнде A или
       B. И там есть методы createBar, createKek... Упрощает замену
       семейств продуктов, но поддерживать новый продукт трудно.
    2. Фабричный метод (factory method): Пишем абстрактный метод
       который создает класс, а в других методах пишем как
       работать с этим объектом на основании того, каким его
       вернет этот factoryMethod. В чилде нашего класса определяем
       метод factoryMethod. Можно добавлять хуки.
    3. Builder (строитель): пишем класс Director который пользуется
       классом Builder чтобы создать объект, у Director есть метод
       construct(). У Builder есть поля в духе
       "buildPart". Конкретный билдер можно менять. Избавляет от
       сложного процесса конструирования и от большого количества
       параметров. И от использования settеров.
    4. Singleton: класс в котором лежит статическая переменная. Вот
       мы ей и пользуемся через методы этого класса. Уменьшает число
       имен и количество глобальных переменных. Но сложнее писать
       тесты.
    5. Object pool: набор готовых и рабочих объектов. Делаем acquire,
       делаем с объектом что хотим, потом возвращаем обратно в
       пул. Экономим объекты, выставляем политики использования.
  * Структурные
    1. Адаптер: берем интерфейс I, который нам не нравится, делаем
       интерфейс Adapter который нам нравится. Пишем имплементацию
       Adaptee, в которой имеем полем что-то интерфейса I. Это
       через делегирование. Через наследование -- Adaptee наследует
       что-то имплементирующее I. Плюсы наследования -- не надо
       создавать новый объект. Нужно добавлять только необходимые
       методы. Минусы -- нужно вставлять заглушки для
       переопределямых методов. Делегирование -- можно работать с
       несколькими адаптируемыми объектами, содержит только нужные
       методы, но замещать операции сложно -- нужно копипаст.
    2. Фасад: пишем класс который объединяет несколько
       функциональностей, образуя более общую систему с более
       простым api. Хорошо, если зависимости внутри сложные. Не
       препятствует обращаться к классам.
    3. Прокси: делаем P наследует интерфейс I, где P это просто
       обертка над каким-то A который наследует I (с
       опц. функциональностью). Плюсы -- дополнительная стата,
       логирование, локи. Ленивое создание тяжелого объекта.
    4. Декоратор: наследуем от I класс A и класс D, в классе D
       лежит полем A, основная функциональность m() через него
       заимплементироавна. От D можно наследовать C и там делать
       что-то перед и после вызовом метода m(). Можно
       стекать. Работает динамически.
    5. Bridge (мост): создаем класс A в который заворачиваем
       B. Все.
    6. Composite (компоновщик): объединить объекты в древовидную
       структуру. Создаем класс C который содержит список
       I. Наследуем C от I в котором все методы делают forall in
       list m(). Пишем в C методы для добавления и удаления детей.
    7. Flyweight (приспособленец): пишем интерфейс F и фабрику FF,
       которая является пулом -- создает новый только если нету
       ничего с нужными параметрами.
  * Поведенческие
    1. Chain of responsibility: обработай сам или дай обработать
       кому-то другому. Можно на делегации (сабкласс -- это
       следующий хэндлер)
    2. Observer: есть некоторый класс Observer который хочет
       коллбэки. Есть мы, которые умеем к себе применять
       observer. Мы обновляем его на действия. Помогает сделать
       широковещательные обновления.
    3. Strategy: то же, что и bridge -- абстрагируем семейство
       алгоритмов. Храним внутри стратегии несколько алгоритмов,
       умеем траверсить.
    4. Template method: шаблонный метод -- определяем скелет
       алгоритма, позволяя наследникам определить что-то. В
       хаскеле -- абстракция констрейнтами.
    5. Visitor: определяем что-то, что может изменяться, если в
       него класть объекты A. В A есть метод accept(v) который по
       сути делает v.visit(this). Ну или перебирает visit по
       подкомпонентам. Упрощает добавление новых
       операций. Аккумулирует состояние при обходе.
    6. State: кладем внутрь некоторый state-interface и работаем в
       нашем классе с полем класса как со своим стейтом.
    7. Interpreter: класс который работает как дататайп --
       конструируется от себя и умеет evaluate().
    8. Null object: имплементация алгоритма или класса, которая
          ничего не делает.
